// Generated at Thu Apr 16 11:49:04 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="lcg-g++-4.8.1"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/share/gccxml-0.9/GCC/4.8" -isystem"/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCGCMT/LCGCMT_68/LCG_Settings/../../../LCG_68/gcc/4.8.1/x86_64-slc6/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include" -isystem"/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCGCMT/LCGCMT_68/LCG_Settings/../../../LCG_68/gcc/4.8.1/x86_64-slc6/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed" -isystem"/cvmfs/lhcb.cern.ch/lib/lcg/releases/gcc/4.8.1/x86_64-slc6/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/cvmfs/lhcb.cern.ch/lib/lcg/releases/gcc/4.8.1/x86_64-slc6/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-unknown-linux-gnu" -isystem"/cvmfs/lhcb.cern.ch/lib/lcg/releases/gcc/4.8.1/x86_64-slc6/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/usr/local/include" -isystem"/cvmfs/lhcb.cern.ch/lib/lcg/releases/gcc/4.8.1/x86_64-slc6/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/lhcb.cern.ch/lib/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.8.1 (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/vols/lhcbdisk05/ss4314/cmtuser/Urania_v2r4/PIDCalib/PIDPerfTools/dict/PIDPerfToolsDict.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_133 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_934 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_230 = ::Reflex::TypeBuilder(Reflex::Literal("TH2F"));
  ::Reflex::Type type_600 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_98 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2542 = ::Reflex::TypeBuilder(Reflex::Literal("TH1"));
  ::Reflex::Type type_223 = ::Reflex::TypeBuilder(Reflex::Literal("TH1F"));
  ::Reflex::Type type_242 = ::Reflex::TypeBuilder(Reflex::Literal("TH3F"));
  ::Reflex::Type type_177 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1100 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_179 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_758 = ::Reflex::TypeBuilder(Reflex::Literal("TFile"));
  ::Reflex::Type type_1418 = ::Reflex::TypeBuilder(Reflex::Literal("TCut"));
  ::Reflex::Type type_2690 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_623 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1847 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_2553 = ::Reflex::TypeBuilder(Reflex::Literal("TNamed"));
  ::Reflex::Type type_1696 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2475 = ::Reflex::TypeBuilder(Reflex::Literal("TString"));
  ::Reflex::Type type_1802 = ::Reflex::TypeBuilder(Reflex::Literal("PIDTable"));
  ::Reflex::Type type_1015 = ::Reflex::TypeBuilder(Reflex::Literal("RooArgSet"));
  ::Reflex::Type type_456 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinning"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("TEntryList"));
  ::Reflex::Type type_1152 = ::Reflex::TypeBuilder(Reflex::Literal("PIDResult"));
  ::Reflex::Type type_1814 = ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet"));
  ::Reflex::Type type_1004 = ::Reflex::TypeBuilder(Reflex::Literal("RooRealVar"));
  ::Reflex::Type type_2238 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData"));
  ::Reflex::Type type_190 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1537 = ::Reflex::TypeBuilder(Reflex::Literal("TEfficiency"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("DataBinCuts"));
  ::Reflex::Type type_511 = ::Reflex::TypeBuilder(Reflex::Literal("PIDCrossTable"));
  ::Reflex::Type type_1877 = ::Reflex::TypeBuilder(Reflex::Literal("TrackDataSet"));
  ::Reflex::Type type_156 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_2455 = ::Reflex::TypeBuilder(Reflex::Literal("TrkPIDParams"));
  ::Reflex::Type type_952 = ::Reflex::TypeBuilder(Reflex::Literal("PIDTrackDataSet"));
  ::Reflex::Type type_2102 = ::Reflex::TypeBuilder(Reflex::Literal("GenericDataSet"));
  ::Reflex::Type type_2710 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<int>"));
  ::Reflex::Type type_1564 = ::Reflex::TypeBuilder(Reflex::Literal("EvtTrackDataSet"));
  ::Reflex::Type type_471 = ::Reflex::TypeBuilder(Reflex::Literal("RICHTrackDataSet"));
  ::Reflex::Type type_386 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_700 = ::Reflex::TypeBuilder(Reflex::Literal("MUONTrackDataSet"));
  ::Reflex::Type type_440 = ::Reflex::TypeBuilder(Reflex::Literal("TGraphAsymmErrors"));
  ::Reflex::Type type_9016 = ::Reflex::EnumTypeBuilder(Reflex::Literal("PIDTable::Bit"));
  ::Reflex::Type type_974 = ::Reflex::TypeBuilder(Reflex::Literal("MultiTrackCalibTool"));
  ::Reflex::Type type_2758 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1763 = ::Reflex::TypeBuilder(Reflex::Literal("LHCbPIDTrackDataSet"));
  ::Reflex::Type type_2753 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PIDResult>"));
  ::Reflex::Type type_4889 = ::Reflex::EnumTypeBuilder(Reflex::Literal("PIDCrossTable::Bit"));
  ::Reflex::Type type_2993 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<float,float>"));
  ::Reflex::Type type_2782 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_9017 = ::Reflex::EnumTypeBuilder(Reflex::Literal("PIDTable::Separator"));
  ::Reflex::Type type_2751 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooBinning*>"));
  ::Reflex::Type type_3112 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PIDResult>"));
  ::Reflex::Type type_3108 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooBinning*>"));
  ::Reflex::Type type_4890 = ::Reflex::EnumTypeBuilder(Reflex::Literal("PIDCrossTable::Separator"));
  ::Reflex::Type type_2381 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<TrackDataSet>"));
  ::Reflex::Type type_2375 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<GenericDataSet>"));
  ::Reflex::Type type_1400 = ::Reflex::TypeBuilder(Reflex::Literal("WeightDataSetTool<TrackDataSet>"));
  ::Reflex::Type type_2377 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<PIDTrackDataSet>"));
  ::Reflex::Type type_2380 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<EvtTrackDataSet>"));
  ::Reflex::Type type_2378 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<MUONTrackDataSet>"));
  ::Reflex::Type type_2379 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<RICHTrackDataSet>"));
  ::Reflex::Type type_2755 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,float> >"));
  ::Reflex::Type type_1396 = ::Reflex::TypeBuilder(Reflex::Literal("WeightDataSetTool<PIDTrackDataSet>"));
  ::Reflex::Type type_1399 = ::Reflex::TypeBuilder(Reflex::Literal("WeightDataSetTool<EvtTrackDataSet>"));
  ::Reflex::Type type_1397 = ::Reflex::TypeBuilder(Reflex::Literal("WeightDataSetTool<MUONTrackDataSet>"));
  ::Reflex::Type type_1398 = ::Reflex::TypeBuilder(Reflex::Literal("WeightDataSetTool<RICHTrackDataSet>"));
  ::Reflex::Type type_2712 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<std::basic_string<char> >"));
  ::Reflex::Type type_2376 = ::Reflex::TypeBuilder(Reflex::Literal("PerfCalculator<LHCbPIDTrackDataSet>"));
  ::Reflex::Type type_2752 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_2916 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,TH1*>"));
  ::Reflex::Type type_3111 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::basic_string<char> >"));
  ::Reflex::Type type_2917 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,RooRealVar*>"));
  ::Reflex::Type type_2913 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,TrkPIDParams>"));
  ::Reflex::Type type_2991 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,RooBinning*>"));
  ::Reflex::Type type_2700 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2914 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<void*> >"));
  ::Reflex::Type type_8056 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<PIDResult> >"));
  ::Reflex::Type type_8057 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooBinning*> >"));
  ::Reflex::Type type_2725 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PIDResult,std::allocator<PIDResult> >"));
  ::Reflex::Type type_2915 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_2711 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >"));
  ::Reflex::Type type_2990 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_2726 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooBinning*,std::allocator<RooBinning*> >"));
  ::Reflex::Type type_3113 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,RooBinning*> >"));
  ::Reflex::Type type_3076 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_node<std::pair<std::basic_string<char>,RooBinning*> >"));
  ::Reflex::Type type_7973 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >"));
  ::Reflex::Type type_2955 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >"));
  ::Reflex::Type type_7975 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >"));
  ::Reflex::Type type_8062 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_7974 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PIDResult*,std::vector<PIDResult> >"));
  ::Reflex::Type type_1912 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_2708 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_const_iterator<std::pair<std::basic_string<char>,RooBinning*> >"));
  ::Reflex::Type type_7976 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooBinning* const*,std::vector<RooBinning*> >"));
  ::Reflex::Type type_3107 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_3130 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::_List_node<std::pair<std::basic_string<char>,RooBinning*> > >"));
  ::Reflex::Type type_2731 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_3224 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> > >"));
  ::Reflex::Type type_3246 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> > >"));
  ::Reflex::Type type_3226 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> > >"));
  ::Reflex::Type type_7985 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_3223 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PIDResult*,std::vector<PIDResult> > >"));
  ::Reflex::Type type_3245 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_List_const_iterator<std::pair<std::basic_string<char>,RooBinning*> > >"));
  ::Reflex::Type type_3225 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooBinning* const*,std::vector<RooBinning*> > >"));
  ::Reflex::Type type_7986 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_8060 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_3244 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_3243 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_3073 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_base<std::pair<std::basic_string<char>,RooBinning*>,std::allocator<std::pair<std::basic_string<char>,RooBinning*> > >"));
  ::Reflex::Type type_2729 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_7981 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_7982 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_3238 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_3237 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_6779 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PIDResult::Container"), type_2753);
  ::Reflex::Type type_471c = ::Reflex::ConstBuilder(type_471);
  ::Reflex::Type type_18625 = ::Reflex::ReferenceBuilder(type_471c);
  ::Reflex::Type type_2791 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2782);
  ::Reflex::Type type_2791c = ::Reflex::ConstBuilder(type_2791);
  ::Reflex::Type type_17755 = ::Reflex::ReferenceBuilder(type_2791c);
  ::Reflex::Type type_18626 = ::Reflex::PointerBuilder(type_1814);
  ::Reflex::Type type_1015c = ::Reflex::ConstBuilder(type_1015);
  ::Reflex::Type type_18462 = ::Reflex::ReferenceBuilder(type_1015c);
  ::Reflex::Type type_18627 = ::Reflex::PointerBuilder(type_471);
  ::Reflex::Type type_6054 = ::Reflex::PointerBuilder(type_2690);
  ::Reflex::Type type_18628 = ::Reflex::ReferenceBuilder(type_471);
  ::Reflex::Type type_1004c = ::Reflex::ConstBuilder(type_1004);
  ::Reflex::Type type_18630 = ::Reflex::PointerBuilder(type_1004c);
  ::Reflex::Type type_15004 = ::Reflex::PointerBuilder(type_2238);
  ::Reflex::Type type_18631 = ::Reflex::ReferenceBuilder(type_2751);
  ::Reflex::Type type_6055 = ::Reflex::PointerBuilder(type_1847);
  ::Reflex::Type type_934c = ::Reflex::ConstBuilder(type_934);
  ::Reflex::Type type_3383 = ::Reflex::PointerBuilder(type_934c);
  ::Reflex::Type type_2392 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_179);
  ::Reflex::Type type_18477 = ::Reflex::ReferenceBuilder(type_386);
  ::Reflex::Type type_4831 = ::Reflex::ReferenceBuilder(type_1696);
  ::Reflex::Type type_230c = ::Reflex::ConstBuilder(type_230);
  ::Reflex::Type type_18641 = ::Reflex::PointerBuilder(type_230c);
  ::Reflex::Type type_456c = ::Reflex::ConstBuilder(type_456);
  ::Reflex::Type type_18642 = ::Reflex::PointerBuilder(type_456c);
  ::Reflex::Type type_2077 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Double_t"), type_623);
  ::Reflex::Type type_601 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_600);
  ::Reflex::Type type_2552 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("UInt_t"), type_190);
  ::Reflex::Type type_18643 = ::Reflex::ReferenceBuilder(type_511);
  ::Reflex::Type type_511c = ::Reflex::ConstBuilder(type_511);
  ::Reflex::Type type_18644 = ::Reflex::ReferenceBuilder(type_511c);
  ::Reflex::Type type_18645 = ::Reflex::PointerBuilder(type_230);
  ::Reflex::Type type_12965 = ::Reflex::PointerBuilder(type_456);
  ::Reflex::Type type_2701 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_2700);
  ::Reflex::Type type_7167 = ::Reflex::ReferenceBuilder(type_2701);
  ::Reflex::Type type_700c = ::Reflex::ConstBuilder(type_700);
  ::Reflex::Type type_18707 = ::Reflex::ReferenceBuilder(type_700c);
  ::Reflex::Type type_18708 = ::Reflex::PointerBuilder(type_700);
  ::Reflex::Type type_18709 = ::Reflex::ReferenceBuilder(type_700);
  ::Reflex::Type type_952c = ::Reflex::ConstBuilder(type_952);
  ::Reflex::Type type_18790 = ::Reflex::ReferenceBuilder(type_952c);
  ::Reflex::Type type_18791 = ::Reflex::PointerBuilder(type_952);
  ::Reflex::Type type_18792 = ::Reflex::ReferenceBuilder(type_952);
  ::Reflex::Type type_1165 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_133);
  ::Reflex::Type type_18546 = ::Reflex::PointerBuilder(type_252);
  ::Reflex::Type type_18736 = ::Reflex::PointerBuilder(type_758);
  ::Reflex::Type type_2447 = ::Reflex::PointerBuilder(type_1100);
  ::Reflex::Type type_2261 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Float_t"), type_98);
  ::Reflex::Type type_18801 = ::Reflex::ReferenceBuilder(type_974);
  ::Reflex::Type type_974c = ::Reflex::ConstBuilder(type_974);
  ::Reflex::Type type_18802 = ::Reflex::ReferenceBuilder(type_974c);
  ::Reflex::Type type_12078 = ::Reflex::PointerBuilder(type_2542);
  ::Reflex::Type type_13104 = ::Reflex::ReferenceBuilder(type_1152);
  ::Reflex::Type type_1152c = ::Reflex::ConstBuilder(type_1152);
  ::Reflex::Type type_13106 = ::Reflex::ReferenceBuilder(type_1152c);
  ::Reflex::Type type_2752c = ::Reflex::ConstBuilder(type_2752);
  ::Reflex::Type type_18842 = ::Reflex::ReferenceBuilder(type_2752c);
  ::Reflex::Type type_2758c = ::Reflex::ConstBuilder(type_2758);
  ::Reflex::Type type_18843 = ::Reflex::ReferenceBuilder(type_2758c);
  ::Reflex::Type type_18941 = ::Reflex::ReferenceBuilder(type_1396);
  ::Reflex::Type type_1396c = ::Reflex::ConstBuilder(type_1396);
  ::Reflex::Type type_18942 = ::Reflex::ReferenceBuilder(type_1396c);
  ::Reflex::Type type_2782c = ::Reflex::ConstBuilder(type_2782);
  ::Reflex::Type type_13041 = ::Reflex::ReferenceBuilder(type_2782c);
  ::Reflex::Type type_18945 = ::Reflex::ReferenceBuilder(type_1397);
  ::Reflex::Type type_1397c = ::Reflex::ConstBuilder(type_1397);
  ::Reflex::Type type_18946 = ::Reflex::ReferenceBuilder(type_1397c);
  ::Reflex::Type type_18947 = ::Reflex::ReferenceBuilder(type_1398);
  ::Reflex::Type type_1398c = ::Reflex::ConstBuilder(type_1398);
  ::Reflex::Type type_18948 = ::Reflex::ReferenceBuilder(type_1398c);
  ::Reflex::Type type_1564c = ::Reflex::ConstBuilder(type_1564);
  ::Reflex::Type type_19036 = ::Reflex::ReferenceBuilder(type_1564c);
  ::Reflex::Type type_18949 = ::Reflex::PointerBuilder(type_1564);
  ::Reflex::Type type_19037 = ::Reflex::ReferenceBuilder(type_1564);
  ::Reflex::Type type_18950 = ::Reflex::ReferenceBuilder(type_1399);
  ::Reflex::Type type_1399c = ::Reflex::ConstBuilder(type_1399);
  ::Reflex::Type type_18951 = ::Reflex::ReferenceBuilder(type_1399c);
  ::Reflex::Type type_1877c = ::Reflex::ConstBuilder(type_1877);
  ::Reflex::Type type_20235 = ::Reflex::ReferenceBuilder(type_1877c);
  ::Reflex::Type type_1821 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_156);
  ::Reflex::Type type_18952 = ::Reflex::PointerBuilder(type_1877);
  ::Reflex::Type type_2475c = ::Reflex::ConstBuilder(type_2475);
  ::Reflex::Type type_20236 = ::Reflex::ReferenceBuilder(type_1877);
  ::Reflex::Type type_2751c = ::Reflex::ConstBuilder(type_2751);
  ::Reflex::Type type_20237 = ::Reflex::ReferenceBuilder(type_2751c);
  ::Reflex::Type type_20238 = ::Reflex::ReferenceBuilder(type_2752);
  ::Reflex::Type type_18953 = ::Reflex::ReferenceBuilder(type_1400);
  ::Reflex::Type type_1400c = ::Reflex::ConstBuilder(type_1400);
  ::Reflex::Type type_18954 = ::Reflex::ReferenceBuilder(type_1400c);
  ::Reflex::Type type_1763c = ::Reflex::ConstBuilder(type_1763);
  ::Reflex::Type type_20164 = ::Reflex::ReferenceBuilder(type_1763c);
  ::Reflex::Type type_20165 = ::Reflex::PointerBuilder(type_1763);
  ::Reflex::Type type_20166 = ::Reflex::ReferenceBuilder(type_1763);
  ::Reflex::Type type_223c = ::Reflex::ConstBuilder(type_223);
  ::Reflex::Type type_20187 = ::Reflex::PointerBuilder(type_223c);
  ::Reflex::Type type_242c = ::Reflex::ConstBuilder(type_242);
  ::Reflex::Type type_20188 = ::Reflex::PointerBuilder(type_242c);
  ::Reflex::Type type_20189 = ::Reflex::ReferenceBuilder(type_1802);
  ::Reflex::Type type_1802c = ::Reflex::ConstBuilder(type_1802);
  ::Reflex::Type type_20190 = ::Reflex::ReferenceBuilder(type_1802c);
  ::Reflex::Type type_20121 = ::Reflex::PointerBuilder(type_223);
  ::Reflex::Type type_20191 = ::Reflex::PointerBuilder(type_242);
  ::Reflex::Type type_9616 = ::Reflex::ReferenceBuilder(type_2990);
  ::Reflex::Type type_2990c = ::Reflex::ConstBuilder(type_2990);
  ::Reflex::Type type_9618 = ::Reflex::ReferenceBuilder(type_2990c);
  ::Reflex::Type type_9612 = ::Reflex::PointerBuilder(type_2990);
  ::Reflex::Type type_9614 = ::Reflex::PointerBuilder(type_2990c);
  ::Reflex::Type type_3087 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_156);
  ::Reflex::Type type_2840 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_177);
  ::Reflex::Type type_3107c = ::Reflex::ConstBuilder(type_3107);
  ::Reflex::Type type_20244 = ::Reflex::ReferenceBuilder(type_3107c);
  ::Reflex::Type type_1912c = ::Reflex::ConstBuilder(type_1912);
  ::Reflex::Type type_20245 = ::Reflex::ReferenceBuilder(type_1912c);
  ::Reflex::Type type_20246 = ::Reflex::ReferenceBuilder(type_1912);
  ::Reflex::Type type_1913 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("VectorOfStringPairs"), type_1912);
  ::Reflex::Type type_1913c = ::Reflex::ConstBuilder(type_1913);
  ::Reflex::Type type_2102c = ::Reflex::ConstBuilder(type_2102);
  ::Reflex::Type type_20382 = ::Reflex::ReferenceBuilder(type_2102c);
  ::Reflex::Type type_20383 = ::Reflex::ReferenceBuilder(type_1913c);
  ::Reflex::Type type_20384 = ::Reflex::PointerBuilder(type_2102);
  ::Reflex::Type type_20385 = ::Reflex::PointerBuilder(type_1913c);
  ::Reflex::Type type_20386 = ::Reflex::ReferenceBuilder(type_2102);
  ::Reflex::Type type_20511 = ::Reflex::ReferenceBuilder(type_2375);
  ::Reflex::Type type_2375c = ::Reflex::ConstBuilder(type_2375);
  ::Reflex::Type type_20512 = ::Reflex::ReferenceBuilder(type_2375c);
  ::Reflex::Type type_2712c = ::Reflex::ConstBuilder(type_2712);
  ::Reflex::Type type_20513 = ::Reflex::ReferenceBuilder(type_2712c);
  ::Reflex::Type type_19009 = ::Reflex::PointerBuilder(type_440);
  ::Reflex::Type type_2753c = ::Reflex::ConstBuilder(type_2753);
  ::Reflex::Type type_20514 = ::Reflex::ReferenceBuilder(type_2753c);
  ::Reflex::Type type_20515 = ::Reflex::PointerBuilder(type_1537);
  ::Reflex::Type type_12937 = ::Reflex::ReferenceBuilder(type_2700);
  ::Reflex::Type type_20516 = ::Reflex::PointerBuilder(type_1802);
  ::Reflex::Type type_20517 = ::Reflex::PointerBuilder(type_511);
  ::Reflex::Type type_20519 = ::Reflex::ReferenceBuilder(type_2376);
  ::Reflex::Type type_2376c = ::Reflex::ConstBuilder(type_2376);
  ::Reflex::Type type_20520 = ::Reflex::ReferenceBuilder(type_2376c);
  ::Reflex::Type type_20521 = ::Reflex::ReferenceBuilder(type_2377);
  ::Reflex::Type type_2377c = ::Reflex::ConstBuilder(type_2377);
  ::Reflex::Type type_20522 = ::Reflex::ReferenceBuilder(type_2377c);
  ::Reflex::Type type_20523 = ::Reflex::ReferenceBuilder(type_2378);
  ::Reflex::Type type_2378c = ::Reflex::ConstBuilder(type_2378);
  ::Reflex::Type type_20524 = ::Reflex::ReferenceBuilder(type_2378c);
  ::Reflex::Type type_20525 = ::Reflex::ReferenceBuilder(type_2379);
  ::Reflex::Type type_2379c = ::Reflex::ConstBuilder(type_2379);
  ::Reflex::Type type_20526 = ::Reflex::ReferenceBuilder(type_2379c);
  ::Reflex::Type type_20527 = ::Reflex::ReferenceBuilder(type_2380);
  ::Reflex::Type type_2380c = ::Reflex::ConstBuilder(type_2380);
  ::Reflex::Type type_20528 = ::Reflex::ReferenceBuilder(type_2380c);
  ::Reflex::Type type_20529 = ::Reflex::ReferenceBuilder(type_2381);
  ::Reflex::Type type_2381c = ::Reflex::ConstBuilder(type_2381);
  ::Reflex::Type type_20530 = ::Reflex::ReferenceBuilder(type_2381c);
  ::Reflex::Type type_20537 = ::Reflex::ReferenceBuilder(type_2455);
  ::Reflex::Type type_2455c = ::Reflex::ConstBuilder(type_2455);
  ::Reflex::Type type_20538 = ::Reflex::ReferenceBuilder(type_2455c);
  ::Reflex::Type type_20582 = ::Reflex::ReferenceBuilder(type_2503);
  ::Reflex::Type type_2503c = ::Reflex::ConstBuilder(type_2503);
  ::Reflex::Type type_20583 = ::Reflex::ReferenceBuilder(type_2503c);
  ::Reflex::Type type_20584 = ::Reflex::ReferenceBuilder(type_2711);
  ::Reflex::Type type_1418c = ::Reflex::ConstBuilder(type_1418);
  ::Reflex::Type type_2710c = ::Reflex::ConstBuilder(type_2710);
  ::Reflex::Type type_20585 = ::Reflex::ReferenceBuilder(type_2710c);
  ::Reflex::Type type_12557 = ::Reflex::ReferenceBuilder(type_2991);
  ::Reflex::Type type_2991c = ::Reflex::ConstBuilder(type_2991);
  ::Reflex::Type type_12559 = ::Reflex::ReferenceBuilder(type_2991c);
  ::Reflex::Type type_12965c = ::Reflex::ConstBuilder(type_12965);
  ::Reflex::Type type_12976 = ::Reflex::ReferenceBuilder(type_12965c);
  ::Reflex::Type type_12553 = ::Reflex::PointerBuilder(type_2991);
  ::Reflex::Type type_12555 = ::Reflex::PointerBuilder(type_2991c);
  ::Reflex::Type type_3113c = ::Reflex::ConstBuilder(type_3113);
  ::Reflex::Type type_20666 = ::Reflex::ReferenceBuilder(type_3113c);
  ::Reflex::Type type_2711c = ::Reflex::ConstBuilder(type_2711);
  ::Reflex::Type type_20667 = ::Reflex::ReferenceBuilder(type_2711c);
  ::Reflex::Type type_12765 = ::Reflex::PointerBuilder(type_12965);
  ::Reflex::Type type_12972 = ::Reflex::PointerBuilder(type_12965c);
  ::Reflex::Type type_12974 = ::Reflex::ReferenceBuilder(type_12965);
  ::Reflex::Type type_3108c = ::Reflex::ConstBuilder(type_3108);
  ::Reflex::Type type_20703 = ::Reflex::ReferenceBuilder(type_3108c);
  ::Reflex::Type type_12859 = ::Reflex::PointerBuilder(type_2782);
  ::Reflex::Type type_13037 = ::Reflex::PointerBuilder(type_2782c);
  ::Reflex::Type type_13039 = ::Reflex::ReferenceBuilder(type_2782);
  ::Reflex::Type type_3111c = ::Reflex::ConstBuilder(type_3111);
  ::Reflex::Type type_20767 = ::Reflex::ReferenceBuilder(type_3111c);
  ::Reflex::Type type_12746 = ::Reflex::PointerBuilder(type_1152);
  ::Reflex::Type type_13102 = ::Reflex::PointerBuilder(type_1152c);
  ::Reflex::Type type_3112c = ::Reflex::ConstBuilder(type_3112);
  ::Reflex::Type type_20690 = ::Reflex::ReferenceBuilder(type_3112c);
  ::Reflex::Type type_20823 = ::Reflex::ReferenceBuilder(type_2753);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RICHTrackDataSet
#undef __RICHTrackDataSet
#endif
class __RICHTrackDataSet : virtual public ::EvtTrackDataSet {
  public:
  __RICHTrackDataSet();
  virtual ~__RICHTrackDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> >&) throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __PIDCrossTable
#undef __PIDCrossTable
#endif
class __PIDCrossTable {
  public:
  __PIDCrossTable();
  virtual ~__PIDCrossTable() throw();
  void* m_perfHist;
  void* m_rowBinning;
  void* m_colBinning;
  void* m_rowTitle;
  void* m_colTitle;
  void* m_rowUnit;
  void* m_colUnit;
  ::Double_t m_rowScale;
  ::Double_t m_colScale;
  ::Bool_t m_showInPercent;
  ::Bool_t m_showErrors;
  ::Bool_t m_printTotals;
  ::Bool_t m_showTotalsAsAverages;
  ::UInt_t m_rowPrecision;
  ::UInt_t m_colPrecision;
  ::UInt_t m_effPrecision;
  ::UInt_t m_rowWidth;
  ::UInt_t m_colWidth;
  void* m_label;
  void* m_caption;
  ::Bool_t m_sidewaysTable;
  void* m_rowAlignment;
  void* m_colAlignment;
  void* m_positioning;
  void* m_topSeparator;
  void* m_bottomSeparator;
  void* m_colHeaderSeparator;
  void* m_rowSeparator;
  void* m_leftSeparator;
  void* m_rightSeparator;
  void* m_rowHeaderSeparator;
  void* m_colSeparator;
};
#ifdef __MUONTrackDataSet
#undef __MUONTrackDataSet
#endif
class __MUONTrackDataSet : virtual public ::EvtTrackDataSet {
  public:
  __MUONTrackDataSet();
  virtual ~__MUONTrackDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> >&) throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __PIDTrackDataSet
#undef __PIDTrackDataSet
#endif
class __PIDTrackDataSet : virtual public ::EvtTrackDataSet {
  public:
  __PIDTrackDataSet();
  virtual ~__PIDTrackDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> >&) throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __MultiTrackCalibTool
#undef __MultiTrackCalibTool
#endif
class __MultiTrackCalibTool {
  public:
  __MultiTrackCalibTool();
  virtual ~__MultiTrackCalibTool() throw();
  ::std::string m_name;
  ::Bool_t m_verbose;
  ::Int_t m_printFreq;
  ::std::map<std::basic_string<char>,TH1*> m_TrackEffMap;
  ::std::map<std::basic_string<char>,std::basic_string<char> > m_PerfParamMap;
  ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > m_BinningParam;
  unsigned int m_indexNTracks;
  unsigned int m_BinningDimensions;
  ::Bool_t m_BinningVectorSorted;
  ::Bool_t m_KinVarBranchesSet;
  ::Bool_t m_IDVarBranchesSet;
  void* m_InputRefTree;
  void* m_EntryList;
  void* m_OutputFile;
  void* m_OutputTree;
  void* m_sWeight_var;
  ::std::string m_sWeight_name;
  ::std::map<std::basic_string<char>,std::vector<void*> > m_TrackVars;
  ::std::map<std::basic_string<char>,TrkPIDParams> m_TrackPIDVals;
  ::Float_t m_TotPIDEff;
  ::Float_t m_TotPIDErr;
  ::Float_t m_TotPIDEffWeight;
  ::Float_t m_TotPIDErrWeight;
  ::Float_t m_TotWeight;
  ::std::pair<float,float> m_NaiveAverageCounters;
  ::std::pair<float,float> m_NaiveAverageWeightCounters;
  ::std::vector<std::pair<int,float> > m_vTrckIDandFracErrs;
  ::std::vector<std::pair<int,float> > m_vTrckIDandFracErrsWeight;
  ::std::string m_IDVar_suffix;
};
#ifdef __PIDResult
#undef __PIDResult
#endif
class __PIDResult {
  public:
  __PIDResult();
  double Eff;
  double Err_Lo;
  double Err_Hi;
  ::std::vector<std::basic_string<char> > DLL;
  ::std::vector<std::basic_string<char> > CutOp;
  ::std::vector<double> Cut;
};
#ifdef __WeightDataSetTool_PIDTrackDataSet_
#undef __WeightDataSetTool_PIDTrackDataSet_
#endif
class __WeightDataSetTool_PIDTrackDataSet_ {
  public:
  __WeightDataSetTool_PIDTrackDataSet_();
  virtual ~__WeightDataSetTool_PIDTrackDataSet_() throw();
  void* m_RefData;
  void* m_CalData;
  ::std::vector<RooBinning*> m_BinSchema;
  bool m_EmptyBinFlag;
};
#ifdef __WeightDataSetTool_MUONTrackDataSet_
#undef __WeightDataSetTool_MUONTrackDataSet_
#endif
class __WeightDataSetTool_MUONTrackDataSet_ {
  public:
  __WeightDataSetTool_MUONTrackDataSet_();
  virtual ~__WeightDataSetTool_MUONTrackDataSet_() throw();
  void* m_RefData;
  void* m_CalData;
  ::std::vector<RooBinning*> m_BinSchema;
  bool m_EmptyBinFlag;
};
#ifdef __WeightDataSetTool_RICHTrackDataSet_
#undef __WeightDataSetTool_RICHTrackDataSet_
#endif
class __WeightDataSetTool_RICHTrackDataSet_ {
  public:
  __WeightDataSetTool_RICHTrackDataSet_();
  virtual ~__WeightDataSetTool_RICHTrackDataSet_() throw();
  void* m_RefData;
  void* m_CalData;
  ::std::vector<RooBinning*> m_BinSchema;
  bool m_EmptyBinFlag;
};
#ifdef __EvtTrackDataSet
#undef __EvtTrackDataSet
#endif
class __EvtTrackDataSet : public ::TrackDataSet {
  public:
  __EvtTrackDataSet();
  virtual ~__EvtTrackDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> >&) throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __WeightDataSetTool_EvtTrackDataSet_
#undef __WeightDataSetTool_EvtTrackDataSet_
#endif
class __WeightDataSetTool_EvtTrackDataSet_ {
  public:
  __WeightDataSetTool_EvtTrackDataSet_();
  virtual ~__WeightDataSetTool_EvtTrackDataSet_() throw();
  void* m_RefData;
  void* m_CalData;
  ::std::vector<RooBinning*> m_BinSchema;
  bool m_EmptyBinFlag;
};
#ifdef __TrackDataSet
#undef __TrackDataSet
#endif
class __TrackDataSet : public ::RooDataSet {
  public:
  __TrackDataSet();
  virtual ~__TrackDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> > const&) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual const ::std::string Get_ParamName(std::string const&) const throw();
  ::std::map<std::basic_string<char>,RooRealVar*> m_ParamMap;
  ::std::string m_Charge;
};
#ifdef __WeightDataSetTool_TrackDataSet_
#undef __WeightDataSetTool_TrackDataSet_
#endif
class __WeightDataSetTool_TrackDataSet_ {
  public:
  __WeightDataSetTool_TrackDataSet_();
  virtual ~__WeightDataSetTool_TrackDataSet_() throw();
  void* m_RefData;
  void* m_CalData;
  ::std::vector<RooBinning*> m_BinSchema;
  bool m_EmptyBinFlag;
};
#ifdef __LHCbPIDTrackDataSet
#undef __LHCbPIDTrackDataSet
#endif
class __LHCbPIDTrackDataSet : public ::RICHTrackDataSet, public ::MUONTrackDataSet {
  public:
  __LHCbPIDTrackDataSet();
  virtual ~__LHCbPIDTrackDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> >&) throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __PIDTable
#undef __PIDTable
#endif
class __PIDTable {
  public:
  __PIDTable();
  virtual ~__PIDTable() throw();
  void* m_perfHist1D;
  void* m_perfHist2D;
  void* m_perfHist3D;
  void* m_xBinning;
  void* m_yBinning;
  void* m_zBinning;
  void* m_xTitle;
  void* m_yTitle;
  void* m_zTitle;
  void* m_effTitle;
  void* m_xUnit;
  void* m_yUnit;
  void* m_zUnit;
  ::Double_t m_xScale;
  ::Double_t m_yScale;
  ::Double_t m_zScale;
  ::Bool_t m_showInPercent;
  ::Bool_t m_showErrors;
  ::UInt_t m_xPrecision;
  ::UInt_t m_yPrecision;
  ::UInt_t m_zPrecision;
  ::UInt_t m_effPrecision;
  ::UInt_t m_xWidth;
  ::UInt_t m_yWidth;
  ::UInt_t m_zWidth;
  ::UInt_t m_effWidth;
  void* m_label;
  void* m_caption;
  ::Bool_t m_sidewaysTable;
  void* m_xAlignment;
  void* m_yAlignment;
  void* m_zAlignment;
  void* m_effAlignment;
  void* m_positioning;
  void* m_topSeparator;
  void* m_bottomSeparator;
  void* m_headerSeparator;
  void* m_rowSeparator;
  void* m_leftSeparator;
  void* m_rightSeparator;
  void* m_colSeparator;
};
#ifdef __std__pair_std__basic_string_char__std__basic_string_char_s_
#undef __std__pair_std__basic_string_char__std__basic_string_char_s_
#endif
struct __std__pair_std__basic_string_char__std__basic_string_char_s_ {
  public:
  __std__pair_std__basic_string_char__std__basic_string_char_s_();
  ::std::basic_string<char> first;
  ::std::basic_string<char> second;
};
#ifdef __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_
#undef __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_
#endif
class __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > {
  public:
  __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_();
};
#ifdef __GenericDataSet
#undef __GenericDataSet
#endif
class __GenericDataSet : public ::RooDataSet {
  public:
  __GenericDataSet();
  virtual ~__GenericDataSet() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsData* SetInBinSchema(std::vector<RooBinning*, std::allocator<RooBinning*> > const&) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual const ::std::string Get_ParamName(std::string const&) const throw();
  ::std::map<std::basic_string<char>,RooRealVar*> m_ParamMap;
  ::VectorOfStringPairs m_Aliases;
};
#ifdef __PerfCalculator_GenericDataSet_
#undef __PerfCalculator_GenericDataSet_
#endif
class __PerfCalculator_GenericDataSet_ {
  public:
  __PerfCalculator_GenericDataSet_();
  virtual ~__PerfCalculator_GenericDataSet_() throw();
  void* m_Data;
};
#ifdef __PerfCalculator_LHCbPIDTrackDataSet_
#undef __PerfCalculator_LHCbPIDTrackDataSet_
#endif
class __PerfCalculator_LHCbPIDTrackDataSet_ {
  public:
  __PerfCalculator_LHCbPIDTrackDataSet_();
  virtual ~__PerfCalculator_LHCbPIDTrackDataSet_() throw();
  void* m_Data;
};
#ifdef __PerfCalculator_PIDTrackDataSet_
#undef __PerfCalculator_PIDTrackDataSet_
#endif
class __PerfCalculator_PIDTrackDataSet_ {
  public:
  __PerfCalculator_PIDTrackDataSet_();
  virtual ~__PerfCalculator_PIDTrackDataSet_() throw();
  void* m_Data;
};
#ifdef __PerfCalculator_MUONTrackDataSet_
#undef __PerfCalculator_MUONTrackDataSet_
#endif
class __PerfCalculator_MUONTrackDataSet_ {
  public:
  __PerfCalculator_MUONTrackDataSet_();
  virtual ~__PerfCalculator_MUONTrackDataSet_() throw();
  void* m_Data;
};
#ifdef __PerfCalculator_RICHTrackDataSet_
#undef __PerfCalculator_RICHTrackDataSet_
#endif
class __PerfCalculator_RICHTrackDataSet_ {
  public:
  __PerfCalculator_RICHTrackDataSet_();
  virtual ~__PerfCalculator_RICHTrackDataSet_() throw();
  void* m_Data;
};
#ifdef __PerfCalculator_EvtTrackDataSet_
#undef __PerfCalculator_EvtTrackDataSet_
#endif
class __PerfCalculator_EvtTrackDataSet_ {
  public:
  __PerfCalculator_EvtTrackDataSet_();
  virtual ~__PerfCalculator_EvtTrackDataSet_() throw();
  void* m_Data;
};
#ifdef __PerfCalculator_TrackDataSet_
#undef __PerfCalculator_TrackDataSet_
#endif
class __PerfCalculator_TrackDataSet_ {
  public:
  __PerfCalculator_TrackDataSet_();
  virtual ~__PerfCalculator_TrackDataSet_() throw();
  void* m_Data;
};
#ifdef __TrkPIDParams
#undef __TrkPIDParams
#endif
class __TrkPIDParams {
  public:
  __TrkPIDParams();
  virtual ~__TrkPIDParams() throw();
  ::Float_t TrkPIDEff;
  ::Float_t TrkPIDErr;
  ::Float_t TrkPIDEffWeight;
  ::Float_t TrkPIDErrWeight;
  ::Int_t TrkBinNumber;
};
#ifdef __DataBinCuts
#undef __DataBinCuts
#endif
class __DataBinCuts : public ::TNamed {
  public:
  __DataBinCuts();
  virtual ~__DataBinCuts() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::std::list<std::pair<std::basic_string<char>,RooBinning*> > m_BinDefs;
};
#ifdef __std__pair_std__basic_string_char__RooBinningp_
#undef __std__pair_std__basic_string_char__RooBinningp_
#endif
struct __std__pair_std__basic_string_char__RooBinningp_ {
  public:
  __std__pair_std__basic_string_char__RooBinningp_();
  ::std::basic_string<char> first;
  void* second;
};
#ifdef __std__list_std__pair_std__basic_string_char__RooBinningp_s_
#undef __std__list_std__pair_std__basic_string_char__RooBinningp_s_
#endif
class __std__list_std__pair_std__basic_string_char__RooBinningp_s_ : protected ::std::_List_base<std::pair<std::basic_string<char>,RooBinning*>,std::allocator<std::pair<std::basic_string<char>,RooBinning*> > > {
  public:
  __std__list_std__pair_std__basic_string_char__RooBinningp_s_();
};
#ifdef __std__vector_RooBinningp_
#undef __std__vector_RooBinningp_
#endif
class __std__vector_RooBinningp_ : protected ::std::_Vector_base<RooBinning*,std::allocator<RooBinning*> > {
  public:
  __std__vector_RooBinningp_();
};
#ifdef __std__vector_std__basic_string_char_s_
#undef __std__vector_std__basic_string_char_s_
#endif
class __std__vector_std__basic_string_char_s_ : protected ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > {
  public:
  __std__vector_std__basic_string_char_s_();
};
#ifdef __std__vector_PIDResult_
#undef __std__vector_PIDResult_
#endif
class __std__vector_PIDResult_ : protected ::std::_Vector_base<PIDResult,std::allocator<PIDResult> > {
  public:
  __std__vector_PIDResult_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class RICHTrackDataSet -------------------------------
static void constructor_4771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::RICHTrackDataSet*)arg[0]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::RICHTrackDataSet*)arg[0]);
}

static void constructor_4772( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet();
  else ::new(mem) ::RICHTrackDataSet();
}

static void constructor_4773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 13 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  }
}

static void constructor_4774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void constructor_4775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 13 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  }
}

static void constructor_4776( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::RICHTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RICHTrackDataSet*)arg[2],
      (::RICHTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static void destructor_4777(void*, void * o, const std::vector<void*>&, void *) {
(((::RICHTrackDataSet*)o)->::RICHTrackDataSet::~RICHTrackDataSet)();
}
static  void method_4778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RICHTrackDataSet*)o)->append)(*(::RICHTrackDataSet*)arg[0]);
}

static  void method_4779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::RICHTrackDataSet*)o)->Get_ParamName_ProbNNK)());
  else   (((const ::RICHTrackDataSet*)o)->Get_ParamName_ProbNNK)();
}

static  void method_4780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::RICHTrackDataSet*)o)->Get_ParamName_ProbNNpi)());
  else   (((const ::RICHTrackDataSet*)o)->Get_ParamName_ProbNNpi)();
}

static  void method_4781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::RICHTrackDataSet*)o)->Get_ParamName_ProbNNp)());
  else   (((const ::RICHTrackDataSet*)o)->Get_ParamName_ProbNNp)();
}

static  void method_4782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RICHTrackDataSet*)o)->Get_Param_ProbNNK)());
  else   (((const ::RICHTrackDataSet*)o)->Get_Param_ProbNNK)();
}

static  void method_4783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RICHTrackDataSet*)o)->Get_Param_ProbNNpi)());
  else   (((const ::RICHTrackDataSet*)o)->Get_Param_ProbNNpi)();
}

static  void method_4784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RICHTrackDataSet*)o)->Get_Param_ProbNNp)());
  else   (((const ::RICHTrackDataSet*)o)->Get_Param_ProbNNp)();
}

static  void method_4785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RICHTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]));
  else   (((::RICHTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]);
}

static  void method_4788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RICHTrackDataSet*)o)->Class)());
  else   (((::RICHTrackDataSet*)o)->Class)();
}

static  void method_4789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RICHTrackDataSet*)o)->Class_Name)());
  else   (((::RICHTrackDataSet*)o)->Class_Name)();
}

static  void method_4790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RICHTrackDataSet*)o)->Class_Version)());
  else   (((::RICHTrackDataSet*)o)->Class_Version)();
}

static  void method_4791( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RICHTrackDataSet*)o)->Dictionary)();
}

static  void method_4792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RICHTrackDataSet*)o)->IsA)());
  else   (((const ::RICHTrackDataSet*)o)->IsA)();
}

static  void method_4793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RICHTrackDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RICHTrackDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RICHTrackDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RICHTrackDataSet*)o)->DeclFileName)());
  else   (((::RICHTrackDataSet*)o)->DeclFileName)();
}

static  void method_4797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RICHTrackDataSet*)o)->ImplFileLine)());
  else   (((::RICHTrackDataSet*)o)->ImplFileLine)();
}

static  void method_4798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RICHTrackDataSet*)o)->ImplFileName)());
  else   (((::RICHTrackDataSet*)o)->ImplFileName)();
}

static  void method_4799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RICHTrackDataSet*)o)->DeclFileLine)());
  else   (((::RICHTrackDataSet*)o)->DeclFileLine)();
}

static void method_newdel_471( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RICHTrackDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RICHTrackDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RICHTrackDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RICHTrackDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RICHTrackDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("EvtTrackDataSet")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::EvtTrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TrackDataSet")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::TrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::RooDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::RooAbsData >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::TNamed >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::TObject >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::RooPrintable >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::RICHTrackDataSet,::RooDirItem >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RICHTrackDataSet -------------------------------
void __RICHTrackDataSet_db_datamem(Reflex::Class*);
void __RICHTrackDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RICHTrackDataSet_datamem_bld(&__RICHTrackDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __RICHTrackDataSet_funcmem_bld(&__RICHTrackDataSet_db_funcmem);
void __RICHTrackDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RICHTrackDataSet"), typeid(::RICHTrackDataSet), sizeof(::RICHTrackDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RICHTrackDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1564, ::Reflex::BaseOffset< ::RICHTrackDataSet, ::EvtTrackDataSet >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18625), Reflex::Literal("RICHTrackDataSet"), constructor_4771, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RICHTrackDataSet"), constructor_4772, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18626, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("RICHTrackDataSet"), constructor_4773, 0, "TrackName;Charge;Data;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;DLLK_Name;DLLp_Name;ProbNNK_Name;ProbNNpi_Name;ProbNNp_Name;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18627, type_18462, type_17755, type_17755), Reflex::Literal("RICHTrackDataSet"), constructor_4774, 0, "TrackName;Charge;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_6054, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("RICHTrackDataSet"), constructor_4775, 0, "name;title;ntuple;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;DLLK_Name;DLLp_Name;ProbNNK_Name;ProbNNpi_Name;ProbNNp_Name;cuts=\"\";wgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18627, type_18627, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("RICHTrackDataSet"), constructor_4776, 0, "Name;Charge;Numerator;Denominator;WgtVar;Cuts_Num=\"\";Cuts_Denom=\"\";WgtVar_Num=\"\";WgtVar_Denom=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RICHTrackDataSet"), destructor_4777, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_471, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__RICHTrackDataSet_funcmem_bld);
}

//------Delayed data member builder for class RICHTrackDataSet -------------------
void __RICHTrackDataSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RICHTrackDataSet -------------------
void __RICHTrackDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18628), Reflex::Literal("append"), method_4778, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNK"), method_4779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNpi"), method_4780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNp"), method_4781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNK"), method_4782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNpi"), method_4783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNp"), method_4784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_18631), Reflex::Literal("SetInBinSchema"), method_4785, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_4788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_4789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_4790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_4791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_4793, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_4794, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_4795, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_4796, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_4797, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_4798, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PIDCrossTable -------------------------------
static  void operator_4891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PIDCrossTable*)o)->operator=)(*(const ::PIDCrossTable*)arg[0]);
  else   (((::PIDCrossTable*)o)->operator=)(*(const ::PIDCrossTable*)arg[0]);
}

static void constructor_4892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDCrossTable(*(const ::PIDCrossTable*)arg[0]);
  else ::new(mem) ::PIDCrossTable(*(const ::PIDCrossTable*)arg[0]);
}

static void constructor_4893( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDCrossTable();
  else ::new(mem) ::PIDCrossTable();
}

static void constructor_4894( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDCrossTable((::TH2F*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  else ::new(mem) ::PIDCrossTable((::TH2F*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
}

static  void method_4895( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::PIDCrossTable*)o)->PrintTable)(*(::std::ostream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::PIDCrossTable*)o)->PrintTable)(*(::std::ostream*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_4896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetPerfHist)((const ::TH2F*)arg[0]);
}

static  void method_4897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetBinning)((const ::RooBinning*)arg[0],
    (const ::RooBinning*)arg[1]);
}

static  void method_4898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowBinning)((const ::RooBinning*)arg[0]);
}

static  void method_4899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColBinning)((const ::RooBinning*)arg[0]);
}

static  void method_4900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowTitle)((const char*)arg[0]);
}

static  void method_4901( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColTitle)((const char*)arg[0]);
}

static  void method_4902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowUnit)((const char*)arg[0]);
}

static  void method_4903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColUnit)((const char*)arg[0]);
}

static  void method_4904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_4905( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_4906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetEffPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_4907( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowScale)(*(::Double_t*)arg[0]);
}

static  void method_4908( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColScale)(*(::Double_t*)arg[0]);
}

static  void method_4909( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowWidth)(*(::UInt_t*)arg[0]);
}

static  void method_4910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColWidth)(*(::UInt_t*)arg[0]);
}

static  void method_4911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetBit)(*(::PIDCrossTable::Bit*)arg[0],
    *(::Bool_t*)arg[1]);
}

static  void method_4912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetRowAlignment)((const char*)arg[0]);
}

static  void method_4913( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetColAlignment)((const char*)arg[0]);
}

static  void method_4914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetLabel)((const char*)arg[0]);
}

static  void method_4915( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetCaption)((const char*)arg[0]);
}

static  void method_4916( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetPositioning)((const char*)arg[0]);
}

static  void method_4917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDCrossTable*)o)->SetSeparator)(*(::PIDCrossTable::Separator*)arg[0],
    (const char*)arg[1]);
}

static  void method_4918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetPerfHist)());
  else   (((const ::PIDCrossTable*)o)->GetPerfHist)();
}

static  void method_4919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetRowBinning)());
  else   (((const ::PIDCrossTable*)o)->GetRowBinning)();
}

static  void method_4920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetColBinning)());
  else   (((const ::PIDCrossTable*)o)->GetColBinning)();
}

static  void method_4921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetRowTitle)());
  else   (((const ::PIDCrossTable*)o)->GetRowTitle)();
}

static  void method_4922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetColTitle)());
  else   (((const ::PIDCrossTable*)o)->GetColTitle)();
}

static  void method_4923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetRowUnit)());
  else   (((const ::PIDCrossTable*)o)->GetRowUnit)();
}

static  void method_4924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetColUnit)());
  else   (((const ::PIDCrossTable*)o)->GetColUnit)();
}

static  void method_4925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDCrossTable*)o)->GetRowPrecision)());
  else   (((const ::PIDCrossTable*)o)->GetRowPrecision)();
}

static  void method_4926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDCrossTable*)o)->GetColPrecision)());
  else   (((const ::PIDCrossTable*)o)->GetColPrecision)();
}

static  void method_4927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDCrossTable*)o)->GetEffPrecision)());
  else   (((const ::PIDCrossTable*)o)->GetEffPrecision)();
}

static  void method_4928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::PIDCrossTable*)o)->GetRowScale)());
  else   (((const ::PIDCrossTable*)o)->GetRowScale)();
}

static  void method_4929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::PIDCrossTable*)o)->GetColScale)());
  else   (((const ::PIDCrossTable*)o)->GetColScale)();
}

static  void method_4930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDCrossTable*)o)->GetRowWidth)());
  else   (((const ::PIDCrossTable*)o)->GetRowWidth)();
}

static  void method_4931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDCrossTable*)o)->GetColWidth)());
  else   (((const ::PIDCrossTable*)o)->GetColWidth)();
}

static  void method_4932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::PIDCrossTable*)o)->GetBit)(*(::PIDCrossTable::Bit*)arg[0]));
  else   (((const ::PIDCrossTable*)o)->GetBit)(*(::PIDCrossTable::Bit*)arg[0]);
}

static  void method_4933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetRowAlignment)());
  else   (((const ::PIDCrossTable*)o)->GetRowAlignment)();
}

static  void method_4934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetColAlignment)());
  else   (((const ::PIDCrossTable*)o)->GetColAlignment)();
}

static  void method_4935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetLabel)());
  else   (((const ::PIDCrossTable*)o)->GetLabel)();
}

static  void method_4936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetCaption)());
  else   (((const ::PIDCrossTable*)o)->GetCaption)();
}

static  void method_4937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetPositioning)());
  else   (((const ::PIDCrossTable*)o)->GetPositioning)();
}

static  void method_4938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDCrossTable*)o)->GetSeparator)(*(::PIDCrossTable::Separator*)arg[0]));
  else   (((const ::PIDCrossTable*)o)->GetSeparator)(*(::PIDCrossTable::Separator*)arg[0]);
}

static void destructor_4939(void*, void * o, const std::vector<void*>&, void *) {
(((::PIDCrossTable*)o)->::PIDCrossTable::~PIDCrossTable)();
}
static void method_newdel_511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PIDCrossTable >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PIDCrossTable >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PIDCrossTable >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PIDCrossTable >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PIDCrossTable >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PIDCrossTable -------------------------------
void __PIDCrossTable_db_datamem(Reflex::Class*);
void __PIDCrossTable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PIDCrossTable_datamem_bld(&__PIDCrossTable_db_datamem);
Reflex::GenreflexMemberBuilder __PIDCrossTable_funcmem_bld(&__PIDCrossTable_db_funcmem);
void __PIDCrossTable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PIDCrossTable"), typeid(::PIDCrossTable), sizeof(::PIDCrossTable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("PIDCrossTable::Bit"), Reflex::Literal("ShowPercentage=0;SidewaysTable=1;PrintTotals=2;ShowTotalsAsAverages=3;ShowErrors=4"), &typeid(PIDCrossTable::Bit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("PIDCrossTable::Separator"), Reflex::Literal("Top=0;Bottom=1;Left=2;Right=3;Row=4;Column=5;ColHeader=6;RowHeader=7"), &typeid(PIDCrossTable::Separator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18643, type_18644), Reflex::Literal("operator="), operator_4891, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18644), Reflex::Literal("PIDCrossTable"), constructor_4892, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PIDCrossTable"), constructor_4893, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18645, type_12965, type_12965), Reflex::Literal("PIDCrossTable"), constructor_4894, 0, "perfHist;rowBins;colBins", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PIDCrossTable"), destructor_4939, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PIDCrossTable_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PIDCrossTable_funcmem_bld);
}

//------Delayed data member builder for class PIDCrossTable -------------------
void __PIDCrossTable_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18641, Reflex::Literal("m_perfHist"), OffsetOf(__shadow__::__PIDCrossTable, m_perfHist), ::Reflex::PRIVATE)
  .AddDataMember(type_18642, Reflex::Literal("m_rowBinning"), OffsetOf(__shadow__::__PIDCrossTable, m_rowBinning), ::Reflex::PRIVATE)
  .AddDataMember(type_18642, Reflex::Literal("m_colBinning"), OffsetOf(__shadow__::__PIDCrossTable, m_colBinning), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rowTitle"), OffsetOf(__shadow__::__PIDCrossTable, m_rowTitle), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_colTitle"), OffsetOf(__shadow__::__PIDCrossTable, m_colTitle), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rowUnit"), OffsetOf(__shadow__::__PIDCrossTable, m_rowUnit), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_colUnit"), OffsetOf(__shadow__::__PIDCrossTable, m_colUnit), ::Reflex::PRIVATE)
  .AddDataMember(type_2077, Reflex::Literal("m_rowScale"), OffsetOf(__shadow__::__PIDCrossTable, m_rowScale), ::Reflex::PRIVATE)
  .AddDataMember(type_2077, Reflex::Literal("m_colScale"), OffsetOf(__shadow__::__PIDCrossTable, m_colScale), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_showInPercent"), OffsetOf(__shadow__::__PIDCrossTable, m_showInPercent), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_showErrors"), OffsetOf(__shadow__::__PIDCrossTable, m_showErrors), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_printTotals"), OffsetOf(__shadow__::__PIDCrossTable, m_printTotals), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_showTotalsAsAverages"), OffsetOf(__shadow__::__PIDCrossTable, m_showTotalsAsAverages), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_rowPrecision"), OffsetOf(__shadow__::__PIDCrossTable, m_rowPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_colPrecision"), OffsetOf(__shadow__::__PIDCrossTable, m_colPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_effPrecision"), OffsetOf(__shadow__::__PIDCrossTable, m_effPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_rowWidth"), OffsetOf(__shadow__::__PIDCrossTable, m_rowWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_colWidth"), OffsetOf(__shadow__::__PIDCrossTable, m_colWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_label"), OffsetOf(__shadow__::__PIDCrossTable, m_label), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_caption"), OffsetOf(__shadow__::__PIDCrossTable, m_caption), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_sidewaysTable"), OffsetOf(__shadow__::__PIDCrossTable, m_sidewaysTable), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rowAlignment"), OffsetOf(__shadow__::__PIDCrossTable, m_rowAlignment), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_colAlignment"), OffsetOf(__shadow__::__PIDCrossTable, m_colAlignment), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_positioning"), OffsetOf(__shadow__::__PIDCrossTable, m_positioning), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_topSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_topSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_bottomSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_bottomSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_colHeaderSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_colHeaderSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rowSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_rowSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_leftSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_leftSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rightSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_rightSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rowHeaderSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_rowHeaderSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_colSeparator"), OffsetOf(__shadow__::__PIDCrossTable, m_colSeparator), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PIDCrossTable -------------------
void __PIDCrossTable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_7167, type_601), Reflex::Literal("PrintTable"), method_4895, 0, "os;useLaTeXFormat=kFALSE", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18641), Reflex::Literal("SetPerfHist"), method_4896, 0, "hist", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642, type_18642), Reflex::Literal("SetBinning"), method_4897, 0, "rowBins;colBins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642), Reflex::Literal("SetRowBinning"), method_4898, 0, "bins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642), Reflex::Literal("SetColBinning"), method_4899, 0, "bins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetRowTitle"), method_4900, 0, "title", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetColTitle"), method_4901, 0, "title", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetRowUnit"), method_4902, 0, "unit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetColUnit"), method_4903, 0, "unit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetRowPrecision"), method_4904, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetColPrecision"), method_4905, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetEffPrecision"), method_4906, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2077), Reflex::Literal("SetRowScale"), method_4907, 0, "scale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2077), Reflex::Literal("SetColScale"), method_4908, 0, "scale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetRowWidth"), method_4909, 0, "width", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetColWidth"), method_4910, 0, "width", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4889, type_601), Reflex::Literal("SetBit"), method_4911, 0, "flag;bit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetRowAlignment"), method_4912, 0, "alignment", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetColAlignment"), method_4913, 0, "alignment", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetLabel"), method_4914, 0, "label", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetCaption"), method_4915, 0, "caption", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetPositioning"), method_4916, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4890, type_3383), Reflex::Literal("SetSeparator"), method_4917, 0, "type;sep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18641), Reflex::Literal("GetPerfHist"), method_4918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18642), Reflex::Literal("GetRowBinning"), method_4919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18642), Reflex::Literal("GetColBinning"), method_4920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetRowTitle"), method_4921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetColTitle"), method_4922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetRowUnit"), method_4923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetColUnit"), method_4924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetRowPrecision"), method_4925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetColPrecision"), method_4926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetEffPrecision"), method_4927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2077), Reflex::Literal("GetRowScale"), method_4928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2077), Reflex::Literal("GetColScale"), method_4929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetRowWidth"), method_4930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetColWidth"), method_4931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_4889), Reflex::Literal("GetBit"), method_4932, 0, "flag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetRowAlignment"), method_4933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetColAlignment"), method_4934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetLabel"), method_4935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetCaption"), method_4936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetPositioning"), method_4937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383, type_4890), Reflex::Literal("GetSeparator"), method_4938, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class MUONTrackDataSet -------------------------------
static void constructor_5138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::MUONTrackDataSet*)arg[0]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::MUONTrackDataSet*)arg[0]);
}

static void constructor_5139( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet();
  else ::new(mem) ::MUONTrackDataSet();
}

static void constructor_5140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 14 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  }
  else if ( arg.size() == 16 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15]);
  }
}

static void constructor_5141( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void constructor_5142( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 14 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14]);
  }
  else if ( arg.size() == 16 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15]);
  }
}

static void constructor_5143( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::MUONTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::MUONTrackDataSet*)arg[2],
      (::MUONTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static void destructor_5144(void*, void * o, const std::vector<void*>&, void *) {
(((::MUONTrackDataSet*)o)->::MUONTrackDataSet::~MUONTrackDataSet)();
}
static  void method_5145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MUONTrackDataSet*)o)->append)(*(::MUONTrackDataSet*)arg[0]);
}

static  void method_5146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::MUONTrackDataSet*)o)->Get_ParamName_DLLmu)());
  else   (((const ::MUONTrackDataSet*)o)->Get_ParamName_DLLmu)();
}

static  void method_5147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::MUONTrackDataSet*)o)->Get_ParamName_IsMuon)());
  else   (((const ::MUONTrackDataSet*)o)->Get_ParamName_IsMuon)();
}

static  void method_5148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::MUONTrackDataSet*)o)->Get_ParamName_IsMuonLoose)());
  else   (((const ::MUONTrackDataSet*)o)->Get_ParamName_IsMuonLoose)();
}

static  void method_5149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::MUONTrackDataSet*)o)->Get_ParamName_nShared)());
  else   (((const ::MUONTrackDataSet*)o)->Get_ParamName_nShared)();
}

static  void method_5150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MUONTrackDataSet*)o)->Get_Param_DLLmu)());
  else   (((const ::MUONTrackDataSet*)o)->Get_Param_DLLmu)();
}

static  void method_5151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MUONTrackDataSet*)o)->Get_Param_IsMuon)());
  else   (((const ::MUONTrackDataSet*)o)->Get_Param_IsMuon)();
}

static  void method_5152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MUONTrackDataSet*)o)->Get_Param_IsMuonLoose)());
  else   (((const ::MUONTrackDataSet*)o)->Get_Param_IsMuonLoose)();
}

static  void method_5153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MUONTrackDataSet*)o)->Get_Param_nShared)());
  else   (((const ::MUONTrackDataSet*)o)->Get_Param_nShared)();
}

static  void method_5154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MUONTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]));
  else   (((::MUONTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]);
}

static  void method_5157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MUONTrackDataSet*)o)->Class)());
  else   (((::MUONTrackDataSet*)o)->Class)();
}

static  void method_5158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MUONTrackDataSet*)o)->Class_Name)());
  else   (((::MUONTrackDataSet*)o)->Class_Name)();
}

static  void method_5159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::MUONTrackDataSet*)o)->Class_Version)());
  else   (((::MUONTrackDataSet*)o)->Class_Version)();
}

static  void method_5160( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MUONTrackDataSet*)o)->Dictionary)();
}

static  void method_5161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MUONTrackDataSet*)o)->IsA)());
  else   (((const ::MUONTrackDataSet*)o)->IsA)();
}

static  void method_5162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MUONTrackDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MUONTrackDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MUONTrackDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MUONTrackDataSet*)o)->DeclFileName)());
  else   (((::MUONTrackDataSet*)o)->DeclFileName)();
}

static  void method_5166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MUONTrackDataSet*)o)->ImplFileLine)());
  else   (((::MUONTrackDataSet*)o)->ImplFileLine)();
}

static  void method_5167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MUONTrackDataSet*)o)->ImplFileName)());
  else   (((::MUONTrackDataSet*)o)->ImplFileName)();
}

static  void method_5168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MUONTrackDataSet*)o)->DeclFileLine)());
  else   (((::MUONTrackDataSet*)o)->DeclFileLine)();
}

static void method_newdel_700( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MUONTrackDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MUONTrackDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MUONTrackDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MUONTrackDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MUONTrackDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("EvtTrackDataSet")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::EvtTrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TrackDataSet")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::TrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::RooDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::RooAbsData >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::TNamed >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::TObject >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::RooPrintable >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::MUONTrackDataSet,::RooDirItem >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MUONTrackDataSet -------------------------------
void __MUONTrackDataSet_db_datamem(Reflex::Class*);
void __MUONTrackDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MUONTrackDataSet_datamem_bld(&__MUONTrackDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __MUONTrackDataSet_funcmem_bld(&__MUONTrackDataSet_db_funcmem);
void __MUONTrackDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MUONTrackDataSet"), typeid(::MUONTrackDataSet), sizeof(::MUONTrackDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::MUONTrackDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1564, ::Reflex::BaseOffset< ::MUONTrackDataSet, ::EvtTrackDataSet >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18707), Reflex::Literal("MUONTrackDataSet"), constructor_5138, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MUONTrackDataSet"), constructor_5139, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18626, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("MUONTrackDataSet"), constructor_5140, 0, "TrackName;Charge;Data;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;DLLK_Name;DLLp_Name;DLLmu_Name;IsMuon_Name;IsMuonLoose_Name;nShared_Name;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18708, type_18462, type_17755, type_17755), Reflex::Literal("MUONTrackDataSet"), constructor_5141, 0, "TrackName;Charge;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_6054, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("MUONTrackDataSet"), constructor_5142, 0, "name;title;ntuple;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;DLLK_Name;DLLp_Name;DLLmu_Name;IsMuon_Name;IsMuonLoose_Name;nShared_Name;cuts=\"\";wgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18708, type_18708, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("MUONTrackDataSet"), constructor_5143, 0, "Name;Charge;Numerator;Denominator;WgtVar;Cuts_Num=\"\";Cuts_Denom=\"\";WgtVar_Num=\"\";WgtVar_Denom=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MUONTrackDataSet"), destructor_5144, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_700, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__MUONTrackDataSet_funcmem_bld);
}

//------Delayed data member builder for class MUONTrackDataSet -------------------
void __MUONTrackDataSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class MUONTrackDataSet -------------------
void __MUONTrackDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18709), Reflex::Literal("append"), method_5145, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLmu"), method_5146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_IsMuon"), method_5147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_IsMuonLoose"), method_5148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_nShared"), method_5149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLmu"), method_5150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_IsMuon"), method_5151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_IsMuonLoose"), method_5152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_nShared"), method_5153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_18631), Reflex::Literal("SetInBinSchema"), method_5154, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_5157, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_5158, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_5159, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_5160, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_5161, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_5162, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_5163, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_5164, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_5165, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_5166, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_5167, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_5168, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PIDTrackDataSet -------------------------------
static void constructor_6057( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::PIDTrackDataSet*)arg[0]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::PIDTrackDataSet*)arg[0]);
}

static void constructor_6058( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet();
  else ::new(mem) ::PIDTrackDataSet();
}

static void constructor_6059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 23 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22]);
  }
  else if ( arg.size() == 24 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23]);
  }
  else if ( arg.size() == 25 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23],
      *(const ::std::string*)arg[24]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23],
      *(const ::std::string*)arg[24]);
  }
}

static void constructor_6060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void constructor_6061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 23 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22]);
  }
  else if ( arg.size() == 24 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23]);
  }
  else if ( arg.size() == 25 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23],
      *(const ::std::string*)arg[24]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19],
      *(const ::std::string*)arg[20],
      *(const ::std::string*)arg[21],
      *(const ::std::string*)arg[22],
      *(const ::std::string*)arg[23],
      *(const ::std::string*)arg[24]);
  }
}

static void constructor_6062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::PIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::PIDTrackDataSet*)arg[2],
      (::PIDTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static void destructor_6063(void*, void * o, const std::vector<void*>&, void *) {
(((::PIDTrackDataSet*)o)->::PIDTrackDataSet::~PIDTrackDataSet)();
}
static  void method_6064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTrackDataSet*)o)->append)(*(::PIDTrackDataSet*)arg[0]);
}

static  void method_6065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNK)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNK)();
}

static  void method_6066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNpi)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNpi)();
}

static  void method_6067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNp)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNp)();
}

static  void method_6068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNmu)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNmu)();
}

static  void method_6069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNe)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_ProbNNe)();
}

static  void method_6070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_DLLe)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_DLLe)();
}

static  void method_6071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_DLLmu)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_DLLmu)();
}

static  void method_6072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_IsMuon)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_IsMuon)();
}

static  void method_6073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_IsMuonLoose)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_IsMuonLoose)();
}

static  void method_6074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_nShared)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_nShared)();
}

static  void method_6075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_HasBremAdded)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_HasBremAdded)();
}

static  void method_6076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::PIDTrackDataSet*)o)->Get_ParamName_CaloRegion)());
  else   (((const ::PIDTrackDataSet*)o)->Get_ParamName_CaloRegion)();
}

static  void method_6077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNK)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNK)();
}

static  void method_6078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNpi)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNpi)();
}

static  void method_6079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNp)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNp)();
}

static  void method_6080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNmu)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNmu)();
}

static  void method_6081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNe)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_ProbNNe)();
}

static  void method_6082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_DLLe)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_DLLe)();
}

static  void method_6083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_DLLmu)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_DLLmu)();
}

static  void method_6084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_IsMuon)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_IsMuon)();
}

static  void method_6085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_IsMuonLoose)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_IsMuonLoose)();
}

static  void method_6086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_nShared)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_nShared)();
}

static  void method_6087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_HasBremAdded)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_HasBremAdded)();
}

static  void method_6088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->Get_Param_CaloRegion)());
  else   (((const ::PIDTrackDataSet*)o)->Get_Param_CaloRegion)();
}

static  void method_6089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PIDTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]));
  else   (((::PIDTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]);
}

static  void method_6092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PIDTrackDataSet*)o)->Class)());
  else   (((::PIDTrackDataSet*)o)->Class)();
}

static  void method_6093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PIDTrackDataSet*)o)->Class_Name)());
  else   (((::PIDTrackDataSet*)o)->Class_Name)();
}

static  void method_6094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::PIDTrackDataSet*)o)->Class_Version)());
  else   (((::PIDTrackDataSet*)o)->Class_Version)();
}

static  void method_6095( void*, void* o, const std::vector<void*>&, void*)
{
  (((::PIDTrackDataSet*)o)->Dictionary)();
}

static  void method_6096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTrackDataSet*)o)->IsA)());
  else   (((const ::PIDTrackDataSet*)o)->IsA)();
}

static  void method_6097( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTrackDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTrackDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTrackDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PIDTrackDataSet*)o)->DeclFileName)());
  else   (((::PIDTrackDataSet*)o)->DeclFileName)();
}

static  void method_6101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::PIDTrackDataSet*)o)->ImplFileLine)());
  else   (((::PIDTrackDataSet*)o)->ImplFileLine)();
}

static  void method_6102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PIDTrackDataSet*)o)->ImplFileName)());
  else   (((::PIDTrackDataSet*)o)->ImplFileName)();
}

static  void method_6103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::PIDTrackDataSet*)o)->DeclFileLine)());
  else   (((::PIDTrackDataSet*)o)->DeclFileLine)();
}

static void method_newdel_952( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PIDTrackDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PIDTrackDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PIDTrackDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PIDTrackDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PIDTrackDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("EvtTrackDataSet")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::EvtTrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TrackDataSet")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::TrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::RooDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::RooAbsData >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::TNamed >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::TObject >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::RooPrintable >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::PIDTrackDataSet,::RooDirItem >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PIDTrackDataSet -------------------------------
void __PIDTrackDataSet_db_datamem(Reflex::Class*);
void __PIDTrackDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PIDTrackDataSet_datamem_bld(&__PIDTrackDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __PIDTrackDataSet_funcmem_bld(&__PIDTrackDataSet_db_funcmem);
void __PIDTrackDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PIDTrackDataSet"), typeid(::PIDTrackDataSet), sizeof(::PIDTrackDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::PIDTrackDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1564, ::Reflex::BaseOffset< ::PIDTrackDataSet, ::EvtTrackDataSet >::Get(), ::Reflex::VIRTUAL | ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18790), Reflex::Literal("PIDTrackDataSet"), constructor_6057, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PIDTrackDataSet"), constructor_6058, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18626, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("PIDTrackDataSet"), constructor_6059, 0, "TrackName;Charge;Data;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;nSPDHits_Var;DLLK_Name;DLLp_Name;DLLe_Name;DLLmu_Name;IsMuon_Name;IsMuonLoose_Name;nShared_Name;HasBremAdded_Name;CaloRegion_Name;ProbNNK_Name;ProbNNpi_Name;ProbNNp_Name;ProbNNmu_Name;ProbNNe_Name;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18791, type_18462, type_17755, type_17755), Reflex::Literal("PIDTrackDataSet"), constructor_6060, 0, "TrackName;Charge;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_6054, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("PIDTrackDataSet"), constructor_6061, 0, "name;title;ntuple;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;nSPDHits_Var;DLLK_Name;DLLp_Name;DLLe_Name;DLLmu_Name;IsMuon_Name;IsMuonLoose_Name;nShared_Name;HasBremAdded_Name;CaloRegion_Name;ProbNNK_Name;ProbNNpi_Name;ProbNNp_Name;ProbNNmu_Name;ProbNNe_Name;cuts=\"\";wgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18791, type_18791, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("PIDTrackDataSet"), constructor_6062, 0, "Name;Charge;Numerator;Denominator;WgtVar;Cuts_Num=\"\";Cuts_Denom=\"\";WgtVar_Num=\"\";WgtVar_Denom=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PIDTrackDataSet"), destructor_6063, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_952, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__PIDTrackDataSet_funcmem_bld);
}

//------Delayed data member builder for class PIDTrackDataSet -------------------
void __PIDTrackDataSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PIDTrackDataSet -------------------
void __PIDTrackDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18792), Reflex::Literal("append"), method_6064, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNK"), method_6065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNpi"), method_6066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNp"), method_6067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNmu"), method_6068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ProbNNe"), method_6069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLe"), method_6070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLmu"), method_6071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_IsMuon"), method_6072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_IsMuonLoose"), method_6073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_nShared"), method_6074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_HasBremAdded"), method_6075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_CaloRegion"), method_6076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNK"), method_6077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNpi"), method_6078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNp"), method_6079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNmu"), method_6080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ProbNNe"), method_6081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLe"), method_6082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLmu"), method_6083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_IsMuon"), method_6084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_IsMuonLoose"), method_6085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_nShared"), method_6086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_HasBremAdded"), method_6087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_CaloRegion"), method_6088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_18631), Reflex::Literal("SetInBinSchema"), method_6089, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_6092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_6093, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_6094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_6095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_6096, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_6097, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_6098, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_6099, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_6100, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_6101, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_6102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_6103, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class MultiTrackCalibTool -------------------------------
static  void operator_6203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MultiTrackCalibTool*)o)->operator=)(*(const ::MultiTrackCalibTool*)arg[0]);
  else   (((::MultiTrackCalibTool*)o)->operator=)(*(const ::MultiTrackCalibTool*)arg[0]);
}

static void constructor_6204( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiTrackCalibTool(*(const ::MultiTrackCalibTool*)arg[0]);
  else ::new(mem) ::MultiTrackCalibTool(*(const ::MultiTrackCalibTool*)arg[0]);
}

static void constructor_6205( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2]);
  else ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  else ::new(mem) ::MultiTrackCalibTool(*(::std::string*)arg[0],
      (::TTree*)arg[1],
      *(const ::std::string*)arg[2],
      *(const ::std::string*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static void destructor_6206(void*, void * o, const std::vector<void*>&, void *) {
(((::MultiTrackCalibTool*)o)->::MultiTrackCalibTool::~MultiTrackCalibTool)();
}
static  void method_6207( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->SetTrackMomVarName)(*(const ::std::string*)arg[0]);
}

static  void method_6208( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->SetTrackPtVarName)(*(const ::std::string*)arg[0]);
}

static  void method_6209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->SetTrackEtaVarName)(*(const ::std::string*)arg[0]);
}

static  void method_6210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->SetNTracksVarName)(*(const ::std::string*)arg[0]);
}

static  void method_6211( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->SetSWeightVarName)(*(const ::std::string*)arg[0]);
}

static  void method_6212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->DeclareSignalTrackAndPerfHist)(*(const ::std::string*)arg[0],
    (::TH1*)arg[1]);
}

static  void method_6213( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MultiTrackCalibTool*)o)->SetRefDataInPerfHistLimits)();
}

static  void method_6214( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MultiTrackCalibTool*)o)->CheckSanityOfPerfHists)();
}

static  void method_6215( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MultiTrackCalibTool*)o)->Calculate)();
}

static  void method_6216( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->Calculate)(*(const ::std::string*)arg[0]);
}

static  void method_6217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::pair<float,float>)((((::MultiTrackCalibTool*)o)->CalculateNaiveAverage)());
  else   (((::MultiTrackCalibTool*)o)->CalculateNaiveAverage)();
}

static  void method_6218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::pair<float,float>)((((::MultiTrackCalibTool*)o)->CalculateNaiveWeightAverage)());
  else   (((::MultiTrackCalibTool*)o)->CalculateNaiveWeightAverage)();
}

static  void method_6219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiTrackCalibTool*)o)->Write)(*(::std::string*)arg[0]);
}

//------Dictionary for class MultiTrackCalibTool -------------------------------
void __MultiTrackCalibTool_db_datamem(Reflex::Class*);
void __MultiTrackCalibTool_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MultiTrackCalibTool_datamem_bld(&__MultiTrackCalibTool_db_datamem);
Reflex::GenreflexMemberBuilder __MultiTrackCalibTool_funcmem_bld(&__MultiTrackCalibTool_db_funcmem);
void __MultiTrackCalibTool_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MultiTrackCalibTool"), typeid(::MultiTrackCalibTool), sizeof(::MultiTrackCalibTool), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18801, type_18802), Reflex::Literal("operator="), operator_6203, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18802), Reflex::Literal("MultiTrackCalibTool"), constructor_6204, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2791, type_6054, type_17755, type_17755, type_601, type_1165), Reflex::Literal("MultiTrackCalibTool"), constructor_6205, 0, "Name;RefTreeName;OutputFileName;mode=\"UPDATE\";verbose=kFALSE;printFreq=-0x00000000000000001", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MultiTrackCalibTool"), destructor_6206, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__MultiTrackCalibTool_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MultiTrackCalibTool_funcmem_bld);
}

//------Delayed data member builder for class MultiTrackCalibTool -------------------
void __MultiTrackCalibTool_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2791, Reflex::Literal("m_name"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_name), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_verbose"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_verbose), ::Reflex::PRIVATE)
  .AddDataMember(type_1165, Reflex::Literal("m_printFreq"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_printFreq), ::Reflex::PRIVATE)
  .AddDataMember(type_2916, Reflex::Literal("m_TrackEffMap"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TrackEffMap), ::Reflex::PRIVATE)
  .AddDataMember(type_2915, Reflex::Literal("m_PerfParamMap"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_PerfParamMap), ::Reflex::PRIVATE)
  .AddDataMember(type_1912, Reflex::Literal("m_BinningParam"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_BinningParam), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("m_indexNTracks"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_indexNTracks), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("m_BinningDimensions"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_BinningDimensions), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_BinningVectorSorted"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_BinningVectorSorted), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_KinVarBranchesSet"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_KinVarBranchesSet), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_IDVarBranchesSet"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_IDVarBranchesSet), ::Reflex::PRIVATE)
  .AddDataMember(type_6054, Reflex::Literal("m_InputRefTree"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_InputRefTree), ::Reflex::PRIVATE)
  .AddDataMember(type_18546, Reflex::Literal("m_EntryList"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_EntryList), ::Reflex::PRIVATE)
  .AddDataMember(type_18736, Reflex::Literal("m_OutputFile"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_OutputFile), ::Reflex::PRIVATE)
  .AddDataMember(type_6054, Reflex::Literal("m_OutputTree"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_OutputTree), ::Reflex::PRIVATE)
  .AddDataMember(type_2447, Reflex::Literal("m_sWeight_var"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_sWeight_var), ::Reflex::PRIVATE)
  .AddDataMember(type_2791, Reflex::Literal("m_sWeight_name"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_sWeight_name), ::Reflex::PRIVATE)
  .AddDataMember(type_2914, Reflex::Literal("m_TrackVars"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TrackVars), ::Reflex::PRIVATE)
  .AddDataMember(type_2913, Reflex::Literal("m_TrackPIDVals"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TrackPIDVals), ::Reflex::PRIVATE)
  .AddDataMember(type_2261, Reflex::Literal("m_TotPIDEff"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TotPIDEff), ::Reflex::PRIVATE)
  .AddDataMember(type_2261, Reflex::Literal("m_TotPIDErr"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TotPIDErr), ::Reflex::PRIVATE)
  .AddDataMember(type_2261, Reflex::Literal("m_TotPIDEffWeight"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TotPIDEffWeight), ::Reflex::PRIVATE)
  .AddDataMember(type_2261, Reflex::Literal("m_TotPIDErrWeight"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TotPIDErrWeight), ::Reflex::PRIVATE)
  .AddDataMember(type_2261, Reflex::Literal("m_TotWeight"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_TotWeight), ::Reflex::PRIVATE)
  .AddDataMember(type_2993, Reflex::Literal("m_NaiveAverageCounters"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_NaiveAverageCounters), ::Reflex::PRIVATE)
  .AddDataMember(type_2993, Reflex::Literal("m_NaiveAverageWeightCounters"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_NaiveAverageWeightCounters), ::Reflex::PRIVATE)
  .AddDataMember(type_2755, Reflex::Literal("m_vTrckIDandFracErrs"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_vTrckIDandFracErrs), ::Reflex::PRIVATE)
  .AddDataMember(type_2755, Reflex::Literal("m_vTrckIDandFracErrsWeight"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_vTrckIDandFracErrsWeight), ::Reflex::PRIVATE)
  .AddDataMember(type_2791, Reflex::Literal("m_IDVar_suffix"), OffsetOf(__shadow__::__MultiTrackCalibTool, m_IDVar_suffix), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MultiTrackCalibTool -------------------
void __MultiTrackCalibTool_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755), Reflex::Literal("SetTrackMomVarName"), method_6207, 0, "NameInTree", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755), Reflex::Literal("SetTrackPtVarName"), method_6208, 0, "NameInTree", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755), Reflex::Literal("SetTrackEtaVarName"), method_6209, 0, "NameInTree", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755), Reflex::Literal("SetNTracksVarName"), method_6210, 0, "NameInTree", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755), Reflex::Literal("SetSWeightVarName"), method_6211, 0, "NameInTree", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755, type_12078), Reflex::Literal("DeclareSignalTrackAndPerfHist"), method_6212, 0, "TrackNameInTree;PerfHist", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("SetRefDataInPerfHistLimits"), method_6213, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("CheckSanityOfPerfHists"), method_6214, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Calculate"), method_6215, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755), Reflex::Literal("Calculate"), method_6216, 0, "IDVar_suffix", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2993), Reflex::Literal("CalculateNaiveAverage"), method_6217, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2993), Reflex::Literal("CalculateNaiveWeightAverage"), method_6218, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2791), Reflex::Literal("Write"), method_6219, 0, "name", ::Reflex::PUBLIC);
}
//------Stub functions for class PIDResult -------------------------------
static void destructor_6780(void*, void * o, const std::vector<void*>&, void *) {
(((::PIDResult*)o)->::PIDResult::~PIDResult)();
}
static  void operator_6781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PIDResult*)o)->operator=)(*(const ::PIDResult*)arg[0]);
  else   (((::PIDResult*)o)->operator=)(*(const ::PIDResult*)arg[0]);
}

static void constructor_6782( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(const ::PIDResult*)arg[0]);
  else ::new(mem) ::PIDResult(*(const ::PIDResult*)arg[0]);
}

static void constructor_6783( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult();
  else ::new(mem) ::PIDResult();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(double*)arg[0]);
  else ::new(mem) ::PIDResult(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(const ::std::vector<std::basic_string<char> >*)arg[3]);
  else ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(const ::std::vector<std::basic_string<char> >*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(const ::std::vector<std::basic_string<char> >*)arg[3],
      *(const ::std::vector<std::basic_string<char> >*)arg[4]);
  else ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(const ::std::vector<std::basic_string<char> >*)arg[3],
      *(const ::std::vector<std::basic_string<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(const ::std::vector<std::basic_string<char> >*)arg[3],
      *(const ::std::vector<std::basic_string<char> >*)arg[4],
      *(const ::std::vector<double>*)arg[5]);
  else ::new(mem) ::PIDResult(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(const ::std::vector<std::basic_string<char> >*)arg[3],
      *(const ::std::vector<std::basic_string<char> >*)arg[4],
      *(const ::std::vector<double>*)arg[5]);
  }
}

static void constructor_x7( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDResult();
  else ::new(mem) ::PIDResult();
}

static void method_newdel_1152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PIDResult >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PIDResult >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PIDResult >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PIDResult >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PIDResult >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PIDResult -------------------------------
void __PIDResult_db_datamem(Reflex::Class*);
void __PIDResult_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PIDResult_datamem_bld(&__PIDResult_db_datamem);
Reflex::GenreflexMemberBuilder __PIDResult_funcmem_bld(&__PIDResult_db_funcmem);
void __PIDResult_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PIDResult"), typeid(::PIDResult), sizeof(::PIDResult), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2753, Reflex::Literal("PIDResult::Container"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PIDResult"), destructor_6780, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13104, type_13106), Reflex::Literal("operator="), operator_6781, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13106), Reflex::Literal("PIDResult"), constructor_6782, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_623, type_623, type_623, type_18842, type_18842, type_18843), Reflex::Literal("PIDResult"), constructor_6783, 0, "a=0;b=0;c=0;d=std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >();e=std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >();f=std::vector<double, std::allocator<double> >()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PIDResult"), constructor_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PIDResult_datamem_bld);
}

//------Delayed data member builder for class PIDResult -------------------
void __PIDResult_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_623, Reflex::Literal("Eff"), OffsetOf(__shadow__::__PIDResult, Eff), ::Reflex::PUBLIC)
  .AddDataMember(type_623, Reflex::Literal("Err_Lo"), OffsetOf(__shadow__::__PIDResult, Err_Lo), ::Reflex::PUBLIC)
  .AddDataMember(type_623, Reflex::Literal("Err_Hi"), OffsetOf(__shadow__::__PIDResult, Err_Hi), ::Reflex::PUBLIC)
  .AddDataMember(type_2752, Reflex::Literal("DLL"), OffsetOf(__shadow__::__PIDResult, DLL), ::Reflex::PUBLIC)
  .AddDataMember(type_2752, Reflex::Literal("CutOp"), OffsetOf(__shadow__::__PIDResult, CutOp), ::Reflex::PUBLIC)
  .AddDataMember(type_2758, Reflex::Literal("Cut"), OffsetOf(__shadow__::__PIDResult, Cut), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class PIDResult -------------------
void __PIDResult_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class WeightDataSetTool<PIDTrackDataSet> -------------------------------
static  void operator_7220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::WeightDataSetTool<PIDTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<PIDTrackDataSet>*)arg[0]);
  else   (((::WeightDataSetTool<PIDTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<PIDTrackDataSet>*)arg[0]);
}

static void constructor_7221( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<PIDTrackDataSet>();
  else ::new(mem) ::WeightDataSetTool<PIDTrackDataSet>();
}

static void constructor_7222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<PIDTrackDataSet>((::PIDTrackDataSet*)arg[0],
      (::PIDTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  else ::new(mem) ::WeightDataSetTool<PIDTrackDataSet>((::PIDTrackDataSet*)arg[0],
      (::PIDTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
}

static void constructor_7223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<PIDTrackDataSet>(*(const ::WeightDataSetTool<PIDTrackDataSet>*)arg[0]);
  else ::new(mem) ::WeightDataSetTool<PIDTrackDataSet>(*(const ::WeightDataSetTool<PIDTrackDataSet>*)arg[0]);
}

static void destructor_7224(void*, void * o, const std::vector<void*>&, void *) {
(((::WeightDataSetTool<PIDTrackDataSet>*)o)->::WeightDataSetTool<PIDTrackDataSet>::~WeightDataSetTool)();
}
static  void method_7225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<PIDTrackDataSet>*)o)->ref_data)());
  else   (((const ::WeightDataSetTool<PIDTrackDataSet>*)o)->ref_data)();
}

static  void method_7226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<PIDTrackDataSet>*)o)->cal_data)());
  else   (((const ::WeightDataSetTool<PIDTrackDataSet>*)o)->cal_data)();
}

static  void method_7227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooBinning*>)((((const ::WeightDataSetTool<PIDTrackDataSet>*)o)->bin_schema)());
  else   (((const ::WeightDataSetTool<PIDTrackDataSet>*)o)->bin_schema)();
}

static  void method_7228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<PIDTrackDataSet>*)o)->ANDInBins)());
    else     (((::WeightDataSetTool<PIDTrackDataSet>*)o)->ANDInBins)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<PIDTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::WeightDataSetTool<PIDTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<PIDTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]));
    else     (((::WeightDataSetTool<PIDTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_7229( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<PIDTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::WeightDataSetTool<PIDTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<PIDTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::WeightDataSetTool<PIDTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<PIDTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else     (((::WeightDataSetTool<PIDTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}

static void method_newdel_1396( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<PIDTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<PIDTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<PIDTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<PIDTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<PIDTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class WeightDataSetTool<PIDTrackDataSet> -------------------------------
void __WeightDataSetTool_PIDTrackDataSet__db_datamem(Reflex::Class*);
void __WeightDataSetTool_PIDTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_PIDTrackDataSet__datamem_bld(&__WeightDataSetTool_PIDTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_PIDTrackDataSet__funcmem_bld(&__WeightDataSetTool_PIDTrackDataSet__db_funcmem);
void __WeightDataSetTool_PIDTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("WeightDataSetTool<PIDTrackDataSet>"), typeid(::WeightDataSetTool<PIDTrackDataSet>), sizeof(::WeightDataSetTool<PIDTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "WeightDataSetTool<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18941, type_18942), Reflex::Literal("operator="), operator_7220, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightDataSetTool"), constructor_7221, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18791, type_18791, type_18631), Reflex::Literal("WeightDataSetTool"), constructor_7222, 0, "Ref;Cal;Bin", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18942), Reflex::Literal("WeightDataSetTool"), constructor_7223, 0, "tool", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightDataSetTool"), destructor_7224, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1396, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__WeightDataSetTool_PIDTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__WeightDataSetTool_PIDTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class WeightDataSetTool<PIDTrackDataSet> -------------------
void __WeightDataSetTool_PIDTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18791, Reflex::Literal("m_RefData"), OffsetOf(__shadow__::__WeightDataSetTool_PIDTrackDataSet_, m_RefData), ::Reflex::PRIVATE)
  .AddDataMember(type_18791, Reflex::Literal("m_CalData"), OffsetOf(__shadow__::__WeightDataSetTool_PIDTrackDataSet_, m_CalData), ::Reflex::PRIVATE)
  .AddDataMember(type_2751, Reflex::Literal("m_BinSchema"), OffsetOf(__shadow__::__WeightDataSetTool_PIDTrackDataSet_, m_BinSchema), ::Reflex::PRIVATE)
  .AddDataMember(type_600, Reflex::Literal("m_EmptyBinFlag"), OffsetOf(__shadow__::__WeightDataSetTool_PIDTrackDataSet_, m_EmptyBinFlag), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class WeightDataSetTool<PIDTrackDataSet> -------------------
void __WeightDataSetTool_PIDTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18791), Reflex::Literal("ref_data"), method_7225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18791), Reflex::Literal("cal_data"), method_7226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2751), Reflex::Literal("bin_schema"), method_7227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_13041), Reflex::Literal("ANDInBins"), method_7228, 0, "WgtVar=\"\";WgtVar_Ref=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_601, type_13041, type_13041), Reflex::Literal("WeightInBins"), method_7229, 0, "WgtVar;NormToSumEnties;WgtVar_Ref=\"\";WgtVar_Cal=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class WeightDataSetTool<MUONTrackDataSet> -------------------------------
static  void operator_7238( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::WeightDataSetTool<MUONTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<MUONTrackDataSet>*)arg[0]);
  else   (((::WeightDataSetTool<MUONTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<MUONTrackDataSet>*)arg[0]);
}

static void constructor_7239( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<MUONTrackDataSet>();
  else ::new(mem) ::WeightDataSetTool<MUONTrackDataSet>();
}

static void constructor_7240( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<MUONTrackDataSet>((::MUONTrackDataSet*)arg[0],
      (::MUONTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  else ::new(mem) ::WeightDataSetTool<MUONTrackDataSet>((::MUONTrackDataSet*)arg[0],
      (::MUONTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
}

static void constructor_7241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<MUONTrackDataSet>(*(const ::WeightDataSetTool<MUONTrackDataSet>*)arg[0]);
  else ::new(mem) ::WeightDataSetTool<MUONTrackDataSet>(*(const ::WeightDataSetTool<MUONTrackDataSet>*)arg[0]);
}

static void destructor_7242(void*, void * o, const std::vector<void*>&, void *) {
(((::WeightDataSetTool<MUONTrackDataSet>*)o)->::WeightDataSetTool<MUONTrackDataSet>::~WeightDataSetTool)();
}
static  void method_7243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<MUONTrackDataSet>*)o)->ref_data)());
  else   (((const ::WeightDataSetTool<MUONTrackDataSet>*)o)->ref_data)();
}

static  void method_7244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<MUONTrackDataSet>*)o)->cal_data)());
  else   (((const ::WeightDataSetTool<MUONTrackDataSet>*)o)->cal_data)();
}

static  void method_7245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooBinning*>)((((const ::WeightDataSetTool<MUONTrackDataSet>*)o)->bin_schema)());
  else   (((const ::WeightDataSetTool<MUONTrackDataSet>*)o)->bin_schema)();
}

static  void method_7246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<MUONTrackDataSet>*)o)->ANDInBins)());
    else     (((::WeightDataSetTool<MUONTrackDataSet>*)o)->ANDInBins)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<MUONTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::WeightDataSetTool<MUONTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<MUONTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]));
    else     (((::WeightDataSetTool<MUONTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_7247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<MUONTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::WeightDataSetTool<MUONTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<MUONTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::WeightDataSetTool<MUONTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<MUONTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else     (((::WeightDataSetTool<MUONTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}

static void method_newdel_1397( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<MUONTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<MUONTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<MUONTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<MUONTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<MUONTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class WeightDataSetTool<MUONTrackDataSet> -------------------------------
void __WeightDataSetTool_MUONTrackDataSet__db_datamem(Reflex::Class*);
void __WeightDataSetTool_MUONTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_MUONTrackDataSet__datamem_bld(&__WeightDataSetTool_MUONTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_MUONTrackDataSet__funcmem_bld(&__WeightDataSetTool_MUONTrackDataSet__db_funcmem);
void __WeightDataSetTool_MUONTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("WeightDataSetTool<MUONTrackDataSet>"), typeid(::WeightDataSetTool<MUONTrackDataSet>), sizeof(::WeightDataSetTool<MUONTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "WeightDataSetTool<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18945, type_18946), Reflex::Literal("operator="), operator_7238, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightDataSetTool"), constructor_7239, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18708, type_18708, type_18631), Reflex::Literal("WeightDataSetTool"), constructor_7240, 0, "Ref;Cal;Bin", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18946), Reflex::Literal("WeightDataSetTool"), constructor_7241, 0, "tool", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightDataSetTool"), destructor_7242, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1397, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__WeightDataSetTool_MUONTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__WeightDataSetTool_MUONTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class WeightDataSetTool<MUONTrackDataSet> -------------------
void __WeightDataSetTool_MUONTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18708, Reflex::Literal("m_RefData"), OffsetOf(__shadow__::__WeightDataSetTool_MUONTrackDataSet_, m_RefData), ::Reflex::PRIVATE)
  .AddDataMember(type_18708, Reflex::Literal("m_CalData"), OffsetOf(__shadow__::__WeightDataSetTool_MUONTrackDataSet_, m_CalData), ::Reflex::PRIVATE)
  .AddDataMember(type_2751, Reflex::Literal("m_BinSchema"), OffsetOf(__shadow__::__WeightDataSetTool_MUONTrackDataSet_, m_BinSchema), ::Reflex::PRIVATE)
  .AddDataMember(type_600, Reflex::Literal("m_EmptyBinFlag"), OffsetOf(__shadow__::__WeightDataSetTool_MUONTrackDataSet_, m_EmptyBinFlag), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class WeightDataSetTool<MUONTrackDataSet> -------------------
void __WeightDataSetTool_MUONTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18708), Reflex::Literal("ref_data"), method_7243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18708), Reflex::Literal("cal_data"), method_7244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2751), Reflex::Literal("bin_schema"), method_7245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_13041), Reflex::Literal("ANDInBins"), method_7246, 0, "WgtVar=\"\";WgtVar_Ref=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_601, type_13041, type_13041), Reflex::Literal("WeightInBins"), method_7247, 0, "WgtVar;NormToSumEnties;WgtVar_Ref=\"\";WgtVar_Cal=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class WeightDataSetTool<RICHTrackDataSet> -------------------------------
static  void operator_7256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::WeightDataSetTool<RICHTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<RICHTrackDataSet>*)arg[0]);
  else   (((::WeightDataSetTool<RICHTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<RICHTrackDataSet>*)arg[0]);
}

static void constructor_7257( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<RICHTrackDataSet>();
  else ::new(mem) ::WeightDataSetTool<RICHTrackDataSet>();
}

static void constructor_7258( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<RICHTrackDataSet>((::RICHTrackDataSet*)arg[0],
      (::RICHTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  else ::new(mem) ::WeightDataSetTool<RICHTrackDataSet>((::RICHTrackDataSet*)arg[0],
      (::RICHTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
}

static void constructor_7259( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<RICHTrackDataSet>(*(const ::WeightDataSetTool<RICHTrackDataSet>*)arg[0]);
  else ::new(mem) ::WeightDataSetTool<RICHTrackDataSet>(*(const ::WeightDataSetTool<RICHTrackDataSet>*)arg[0]);
}

static void destructor_7260(void*, void * o, const std::vector<void*>&, void *) {
(((::WeightDataSetTool<RICHTrackDataSet>*)o)->::WeightDataSetTool<RICHTrackDataSet>::~WeightDataSetTool)();
}
static  void method_7261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<RICHTrackDataSet>*)o)->ref_data)());
  else   (((const ::WeightDataSetTool<RICHTrackDataSet>*)o)->ref_data)();
}

static  void method_7262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<RICHTrackDataSet>*)o)->cal_data)());
  else   (((const ::WeightDataSetTool<RICHTrackDataSet>*)o)->cal_data)();
}

static  void method_7263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooBinning*>)((((const ::WeightDataSetTool<RICHTrackDataSet>*)o)->bin_schema)());
  else   (((const ::WeightDataSetTool<RICHTrackDataSet>*)o)->bin_schema)();
}

static  void method_7264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<RICHTrackDataSet>*)o)->ANDInBins)());
    else     (((::WeightDataSetTool<RICHTrackDataSet>*)o)->ANDInBins)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<RICHTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::WeightDataSetTool<RICHTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<RICHTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]));
    else     (((::WeightDataSetTool<RICHTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_7265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<RICHTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::WeightDataSetTool<RICHTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<RICHTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::WeightDataSetTool<RICHTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<RICHTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else     (((::WeightDataSetTool<RICHTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}

static void method_newdel_1398( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<RICHTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<RICHTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<RICHTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<RICHTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<RICHTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class WeightDataSetTool<RICHTrackDataSet> -------------------------------
void __WeightDataSetTool_RICHTrackDataSet__db_datamem(Reflex::Class*);
void __WeightDataSetTool_RICHTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_RICHTrackDataSet__datamem_bld(&__WeightDataSetTool_RICHTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_RICHTrackDataSet__funcmem_bld(&__WeightDataSetTool_RICHTrackDataSet__db_funcmem);
void __WeightDataSetTool_RICHTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("WeightDataSetTool<RICHTrackDataSet>"), typeid(::WeightDataSetTool<RICHTrackDataSet>), sizeof(::WeightDataSetTool<RICHTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "WeightDataSetTool<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18947, type_18948), Reflex::Literal("operator="), operator_7256, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightDataSetTool"), constructor_7257, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18627, type_18627, type_18631), Reflex::Literal("WeightDataSetTool"), constructor_7258, 0, "Ref;Cal;Bin", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18948), Reflex::Literal("WeightDataSetTool"), constructor_7259, 0, "tool", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightDataSetTool"), destructor_7260, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1398, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__WeightDataSetTool_RICHTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__WeightDataSetTool_RICHTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class WeightDataSetTool<RICHTrackDataSet> -------------------
void __WeightDataSetTool_RICHTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18627, Reflex::Literal("m_RefData"), OffsetOf(__shadow__::__WeightDataSetTool_RICHTrackDataSet_, m_RefData), ::Reflex::PRIVATE)
  .AddDataMember(type_18627, Reflex::Literal("m_CalData"), OffsetOf(__shadow__::__WeightDataSetTool_RICHTrackDataSet_, m_CalData), ::Reflex::PRIVATE)
  .AddDataMember(type_2751, Reflex::Literal("m_BinSchema"), OffsetOf(__shadow__::__WeightDataSetTool_RICHTrackDataSet_, m_BinSchema), ::Reflex::PRIVATE)
  .AddDataMember(type_600, Reflex::Literal("m_EmptyBinFlag"), OffsetOf(__shadow__::__WeightDataSetTool_RICHTrackDataSet_, m_EmptyBinFlag), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class WeightDataSetTool<RICHTrackDataSet> -------------------
void __WeightDataSetTool_RICHTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18627), Reflex::Literal("ref_data"), method_7261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18627), Reflex::Literal("cal_data"), method_7262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2751), Reflex::Literal("bin_schema"), method_7263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_13041), Reflex::Literal("ANDInBins"), method_7264, 0, "WgtVar=\"\";WgtVar_Ref=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_601, type_13041, type_13041), Reflex::Literal("WeightInBins"), method_7265, 0, "WgtVar;NormToSumEnties;WgtVar_Ref=\"\";WgtVar_Cal=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class EvtTrackDataSet -------------------------------
static void constructor_7928( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::EvtTrackDataSet*)arg[0]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::EvtTrackDataSet*)arg[0]);
}

static void constructor_7929( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet();
  else ::new(mem) ::EvtTrackDataSet();
}

static void constructor_7930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  }
}

static void constructor_7931( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void constructor_7932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12]);
  }
}

static void constructor_7933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::EvtTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::EvtTrackDataSet*)arg[2],
      (::EvtTrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static void destructor_7934(void*, void * o, const std::vector<void*>&, void *) {
(((::EvtTrackDataSet*)o)->::EvtTrackDataSet::~EvtTrackDataSet)();
}
static  void method_7935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::EvtTrackDataSet*)o)->append)(*(::EvtTrackDataSet*)arg[0]);
}

static  void method_7936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::EvtTrackDataSet*)o)->Get_ParamName_nTrack)());
  else   (((const ::EvtTrackDataSet*)o)->Get_ParamName_nTrack)();
}

static  void method_7937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::EvtTrackDataSet*)o)->Get_ParamName_nSPDHits)());
  else   (((const ::EvtTrackDataSet*)o)->Get_ParamName_nSPDHits)();
}

static  void method_7938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::EvtTrackDataSet*)o)->Get_Param_nTrack)());
  else   (((const ::EvtTrackDataSet*)o)->Get_Param_nTrack)();
}

static  void method_7939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::EvtTrackDataSet*)o)->Get_Param_nSPDHits)());
  else   (((const ::EvtTrackDataSet*)o)->Get_Param_nSPDHits)();
}

static  void method_7940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::EvtTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]));
  else   (((::EvtTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]);
}

static  void method_7943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::EvtTrackDataSet*)o)->Class)());
  else   (((::EvtTrackDataSet*)o)->Class)();
}

static  void method_7944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::EvtTrackDataSet*)o)->Class_Name)());
  else   (((::EvtTrackDataSet*)o)->Class_Name)();
}

static  void method_7945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::EvtTrackDataSet*)o)->Class_Version)());
  else   (((::EvtTrackDataSet*)o)->Class_Version)();
}

static  void method_7946( void*, void* o, const std::vector<void*>&, void*)
{
  (((::EvtTrackDataSet*)o)->Dictionary)();
}

static  void method_7947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::EvtTrackDataSet*)o)->IsA)());
  else   (((const ::EvtTrackDataSet*)o)->IsA)();
}

static  void method_7948( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::EvtTrackDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7949( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::EvtTrackDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7950( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::EvtTrackDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::EvtTrackDataSet*)o)->DeclFileName)());
  else   (((::EvtTrackDataSet*)o)->DeclFileName)();
}

static  void method_7952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::EvtTrackDataSet*)o)->ImplFileLine)());
  else   (((::EvtTrackDataSet*)o)->ImplFileLine)();
}

static  void method_7953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::EvtTrackDataSet*)o)->ImplFileName)());
  else   (((::EvtTrackDataSet*)o)->ImplFileName)();
}

static  void method_7954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::EvtTrackDataSet*)o)->DeclFileLine)());
  else   (((::EvtTrackDataSet*)o)->DeclFileLine)();
}

static void method_newdel_1564( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::EvtTrackDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::EvtTrackDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::EvtTrackDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::EvtTrackDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::EvtTrackDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TrackDataSet")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::TrackDataSet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::RooDataSet >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::RooAbsData >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::EvtTrackDataSet,::RooDirItem >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class EvtTrackDataSet -------------------------------
void __EvtTrackDataSet_db_datamem(Reflex::Class*);
void __EvtTrackDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __EvtTrackDataSet_datamem_bld(&__EvtTrackDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __EvtTrackDataSet_funcmem_bld(&__EvtTrackDataSet_db_funcmem);
void __EvtTrackDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("EvtTrackDataSet"), typeid(::EvtTrackDataSet), sizeof(::EvtTrackDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::EvtTrackDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1877, ::Reflex::BaseOffset< ::EvtTrackDataSet, ::TrackDataSet >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19036), Reflex::Literal("EvtTrackDataSet"), constructor_7928, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EvtTrackDataSet"), constructor_7929, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18626, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("EvtTrackDataSet"), constructor_7930, 0, "TrackName;Charge;Data;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;nSPDHits_Var;DLLK_Name;DLLp_Name;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18949, type_18462, type_17755, type_17755), Reflex::Literal("EvtTrackDataSet"), constructor_7931, 0, "TrackName;Charge;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_6054, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("EvtTrackDataSet"), constructor_7932, 0, "name;title;ntuple;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;nSPDHits_Var;DLLK_Name;DLLp_Name;cuts=\"\";wgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18949, type_18949, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("EvtTrackDataSet"), constructor_7933, 0, "Name;Charge;Numerator;Denominator;WgtVar;Cuts_Num=\"\";Cuts_Denom=\"\";WgtVar_Num=\"\";WgtVar_Denom=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EvtTrackDataSet"), destructor_7934, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1564, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__EvtTrackDataSet_funcmem_bld);
}

//------Delayed data member builder for class EvtTrackDataSet -------------------
void __EvtTrackDataSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class EvtTrackDataSet -------------------
void __EvtTrackDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_19037), Reflex::Literal("append"), method_7935, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_nTrack"), method_7936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_nSPDHits"), method_7937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_nTrack"), method_7938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_nSPDHits"), method_7939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_18631), Reflex::Literal("SetInBinSchema"), method_7940, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_7943, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_7944, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_7945, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_7946, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_7947, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_7948, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_7949, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_7950, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_7951, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_7952, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_7953, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_7954, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class WeightDataSetTool<EvtTrackDataSet> -------------------------------
static  void operator_7274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::WeightDataSetTool<EvtTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<EvtTrackDataSet>*)arg[0]);
  else   (((::WeightDataSetTool<EvtTrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<EvtTrackDataSet>*)arg[0]);
}

static void constructor_7275( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<EvtTrackDataSet>();
  else ::new(mem) ::WeightDataSetTool<EvtTrackDataSet>();
}

static void constructor_7276( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<EvtTrackDataSet>((::EvtTrackDataSet*)arg[0],
      (::EvtTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  else ::new(mem) ::WeightDataSetTool<EvtTrackDataSet>((::EvtTrackDataSet*)arg[0],
      (::EvtTrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
}

static void constructor_7277( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<EvtTrackDataSet>(*(const ::WeightDataSetTool<EvtTrackDataSet>*)arg[0]);
  else ::new(mem) ::WeightDataSetTool<EvtTrackDataSet>(*(const ::WeightDataSetTool<EvtTrackDataSet>*)arg[0]);
}

static void destructor_7278(void*, void * o, const std::vector<void*>&, void *) {
(((::WeightDataSetTool<EvtTrackDataSet>*)o)->::WeightDataSetTool<EvtTrackDataSet>::~WeightDataSetTool)();
}
static  void method_7279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<EvtTrackDataSet>*)o)->ref_data)());
  else   (((const ::WeightDataSetTool<EvtTrackDataSet>*)o)->ref_data)();
}

static  void method_7280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<EvtTrackDataSet>*)o)->cal_data)());
  else   (((const ::WeightDataSetTool<EvtTrackDataSet>*)o)->cal_data)();
}

static  void method_7281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooBinning*>)((((const ::WeightDataSetTool<EvtTrackDataSet>*)o)->bin_schema)());
  else   (((const ::WeightDataSetTool<EvtTrackDataSet>*)o)->bin_schema)();
}

static  void method_7282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<EvtTrackDataSet>*)o)->ANDInBins)());
    else     (((::WeightDataSetTool<EvtTrackDataSet>*)o)->ANDInBins)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<EvtTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::WeightDataSetTool<EvtTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<EvtTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]));
    else     (((::WeightDataSetTool<EvtTrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_7283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<EvtTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::WeightDataSetTool<EvtTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<EvtTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::WeightDataSetTool<EvtTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<EvtTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else     (((::WeightDataSetTool<EvtTrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}

static void method_newdel_1399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<EvtTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<EvtTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<EvtTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<EvtTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<EvtTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class WeightDataSetTool<EvtTrackDataSet> -------------------------------
void __WeightDataSetTool_EvtTrackDataSet__db_datamem(Reflex::Class*);
void __WeightDataSetTool_EvtTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_EvtTrackDataSet__datamem_bld(&__WeightDataSetTool_EvtTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_EvtTrackDataSet__funcmem_bld(&__WeightDataSetTool_EvtTrackDataSet__db_funcmem);
void __WeightDataSetTool_EvtTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("WeightDataSetTool<EvtTrackDataSet>"), typeid(::WeightDataSetTool<EvtTrackDataSet>), sizeof(::WeightDataSetTool<EvtTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "WeightDataSetTool<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18950, type_18951), Reflex::Literal("operator="), operator_7274, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightDataSetTool"), constructor_7275, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18949, type_18949, type_18631), Reflex::Literal("WeightDataSetTool"), constructor_7276, 0, "Ref;Cal;Bin", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18951), Reflex::Literal("WeightDataSetTool"), constructor_7277, 0, "tool", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightDataSetTool"), destructor_7278, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__WeightDataSetTool_EvtTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__WeightDataSetTool_EvtTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class WeightDataSetTool<EvtTrackDataSet> -------------------
void __WeightDataSetTool_EvtTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18949, Reflex::Literal("m_RefData"), OffsetOf(__shadow__::__WeightDataSetTool_EvtTrackDataSet_, m_RefData), ::Reflex::PRIVATE)
  .AddDataMember(type_18949, Reflex::Literal("m_CalData"), OffsetOf(__shadow__::__WeightDataSetTool_EvtTrackDataSet_, m_CalData), ::Reflex::PRIVATE)
  .AddDataMember(type_2751, Reflex::Literal("m_BinSchema"), OffsetOf(__shadow__::__WeightDataSetTool_EvtTrackDataSet_, m_BinSchema), ::Reflex::PRIVATE)
  .AddDataMember(type_600, Reflex::Literal("m_EmptyBinFlag"), OffsetOf(__shadow__::__WeightDataSetTool_EvtTrackDataSet_, m_EmptyBinFlag), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class WeightDataSetTool<EvtTrackDataSet> -------------------
void __WeightDataSetTool_EvtTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18949), Reflex::Literal("ref_data"), method_7279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18949), Reflex::Literal("cal_data"), method_7280, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2751), Reflex::Literal("bin_schema"), method_7281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_13041), Reflex::Literal("ANDInBins"), method_7282, 0, "WgtVar=\"\";WgtVar_Ref=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_601, type_13041, type_13041), Reflex::Literal("WeightInBins"), method_7283, 0, "WgtVar;NormToSumEnties;WgtVar_Ref=\"\";WgtVar_Cal=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class TrackDataSet -------------------------------
static void constructor_9502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::TrackDataSet*)arg[0]);
  else ::new(mem) ::TrackDataSet(*(const ::TrackDataSet*)arg[0]);
}

static  void operator_9503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::TrackDataSet*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_9504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->operator new)(*(::size_t*)arg[0],
    (void*)arg[1]));
  else   (((::TrackDataSet*)o)->operator new)(*(::size_t*)arg[0],
    (void*)arg[1]);
}

static void constructor_9505( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet();
  else ::new(mem) ::TrackDataSet();
}

static void constructor_9506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  }
}

static void constructor_9507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void constructor_9508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TTree*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10]);
  }
}

static void constructor_9509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  else ::new(mem) ::TrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::TrackDataSet*)arg[2],
      (::TrackDataSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8]);
  }
}

static void destructor_9510(void*, void * o, const std::vector<void*>&, void *) {
(((::TrackDataSet*)o)->::TrackDataSet::~TrackDataSet)();
}
static  void method_9511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TString)((((const ::TrackDataSet*)o)->GetCharge)());
  else   (((const ::TrackDataSet*)o)->GetCharge)();
}

static  void method_9512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TrackDataSet*)o)->append)(*(::TrackDataSet*)arg[0]);
}

static  void method_9513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName)(*(const ::std::string*)arg[0]));
  else   (((const ::TrackDataSet*)o)->Get_ParamName)(*(const ::std::string*)arg[0]);
}

static  void method_9514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName_P)());
  else   (((const ::TrackDataSet*)o)->Get_ParamName_P)();
}

static  void method_9515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName_PT)());
  else   (((const ::TrackDataSet*)o)->Get_ParamName_PT)();
}

static  void method_9516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName_ETA)());
  else   (((const ::TrackDataSet*)o)->Get_ParamName_ETA)();
}

static  void method_9517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName_DLLK)());
  else   (((const ::TrackDataSet*)o)->Get_ParamName_DLLK)();
}

static  void method_9518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName_DLLp)());
  else   (((const ::TrackDataSet*)o)->Get_ParamName_DLLp)();
}

static  void method_9519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TrackDataSet*)o)->Get_ParamName_DLLpK)());
  else   (((const ::TrackDataSet*)o)->Get_ParamName_DLLpK)();
}

static  void method_9520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param)(*(const ::std::string*)arg[0]));
  else   (((const ::TrackDataSet*)o)->Get_Param)(*(const ::std::string*)arg[0]);
}

static  void method_9521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param_P)());
  else   (((const ::TrackDataSet*)o)->Get_Param_P)();
}

static  void method_9522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param_PT)());
  else   (((const ::TrackDataSet*)o)->Get_Param_PT)();
}

static  void method_9523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param_ETA)());
  else   (((const ::TrackDataSet*)o)->Get_Param_ETA)();
}

static  void method_9524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param_DLLK)());
  else   (((const ::TrackDataSet*)o)->Get_Param_DLLK)();
}

static  void method_9525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param_DLLp)());
  else   (((const ::TrackDataSet*)o)->Get_Param_DLLp)();
}

static  void method_9526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->Get_Param_DLLpK)());
  else   (((const ::TrackDataSet*)o)->Get_Param_DLLpK)();
}

static  void method_9527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->SetInBinSchema)(*(const ::std::vector<RooBinning*>*)arg[0]));
  else   (((::TrackDataSet*)o)->SetInBinSchema)(*(const ::std::vector<RooBinning*>*)arg[0]);
}

static  void method_9528( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TrackDataSet*)o)->SplitCut)(*(const ::std::string*)arg[0],
    *(::std::vector<std::basic_string<char> >*)arg[1]);
}

static  void method_9529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::TrackDataSet*)o)->FormatCutList)(*(const ::std::string*)arg[0]));
  else   (((::TrackDataSet*)o)->FormatCutList)(*(const ::std::string*)arg[0]);
}

static  void method_9530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::TrackDataSet*)o)->TranslateCut)(*(const ::std::string*)arg[0]));
  else   (((::TrackDataSet*)o)->TranslateCut)(*(const ::std::string*)arg[0]);
}

static  void method_9535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->Class)());
  else   (((::TrackDataSet*)o)->Class)();
}

static  void method_9536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->Class_Name)());
  else   (((::TrackDataSet*)o)->Class_Name)();
}

static  void method_9537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TrackDataSet*)o)->Class_Version)());
  else   (((::TrackDataSet*)o)->Class_Version)();
}

static  void method_9538( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TrackDataSet*)o)->Dictionary)();
}

static  void method_9539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TrackDataSet*)o)->IsA)());
  else   (((const ::TrackDataSet*)o)->IsA)();
}

static  void method_9540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TrackDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TrackDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TrackDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->DeclFileName)());
  else   (((::TrackDataSet*)o)->DeclFileName)();
}

static  void method_9544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TrackDataSet*)o)->ImplFileLine)());
  else   (((::TrackDataSet*)o)->ImplFileLine)();
}

static  void method_9545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TrackDataSet*)o)->ImplFileName)());
  else   (((::TrackDataSet*)o)->ImplFileName)();
}

static  void method_9546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TrackDataSet*)o)->DeclFileLine)());
  else   (((::TrackDataSet*)o)->DeclFileLine)();
}

static void method_newdel_1877( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TrackDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TrackDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TrackDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TrackDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TrackDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::TrackDataSet,::RooDataSet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::TrackDataSet,::RooAbsData >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TrackDataSet,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TrackDataSet,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TrackDataSet,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::TrackDataSet,::RooDirItem >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TrackDataSet -------------------------------
void __TrackDataSet_db_datamem(Reflex::Class*);
void __TrackDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TrackDataSet_datamem_bld(&__TrackDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __TrackDataSet_funcmem_bld(&__TrackDataSet_db_funcmem);
void __TrackDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TrackDataSet"), typeid(::TrackDataSet), sizeof(::TrackDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TrackDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1814, ::Reflex::BaseOffset< ::TrackDataSet, ::RooDataSet >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20235), Reflex::Literal("TrackDataSet"), constructor_9502, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TrackDataSet"), constructor_9505, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18626, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("TrackDataSet"), constructor_9506, 0, "TrackName;Charge;Data;vars;P_Name;PT_Name;ETA_Name;DLLK_Name;DLLp_Name;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18952, type_18462, type_17755, type_17755), Reflex::Literal("TrackDataSet"), constructor_9507, 0, "TrackName;Charge;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_6054, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("TrackDataSet"), constructor_9508, 0, "name;title;ntuple;vars;P_Name;PT_Name;ETA_Name;DLLK_Name;DLLp_Name;cuts=\"\";wgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18952, type_18952, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("TrackDataSet"), constructor_9509, 0, "Name;Charge;Numerator;Denominator;WgtVar;Cuts_Num=\"\";Cuts_Denom=\"\";WgtVar_Num=\"\";WgtVar_Denom=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TrackDataSet"), destructor_9510, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1877, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TrackDataSet_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TrackDataSet_funcmem_bld);
}

//------Delayed data member builder for class TrackDataSet -------------------
void __TrackDataSet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2917, Reflex::Literal("m_ParamMap"), OffsetOf(__shadow__::__TrackDataSet, m_ParamMap), ::Reflex::PRIVATE)
  .AddDataMember(type_2791c, Reflex::Literal("m_Charge"), OffsetOf(__shadow__::__TrackDataSet, m_Charge), ::Reflex::PRIVATE | ::Reflex::CONST);
}
//------Delayed function member builder for class TrackDataSet -------------------
void __TrackDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2447, type_1821), Reflex::Literal("operator new"), operator_9503, 0, "sz", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2447, type_1821, type_2447), Reflex::Literal("operator new"), operator_9504, 0, "sz;vp", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2475c), Reflex::Literal("GetCharge"), method_9511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20236), Reflex::Literal("append"), method_9512, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c, type_17755), Reflex::Literal("Get_ParamName"), method_9513, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_P"), method_9514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_PT"), method_9515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_ETA"), method_9516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLK"), method_9517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLp"), method_9518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLpK"), method_9519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630, type_17755), Reflex::Literal("Get_Param"), method_9520, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_P"), method_9521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_PT"), method_9522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_ETA"), method_9523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLK"), method_9524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLp"), method_9525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLpK"), method_9526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_20237), Reflex::Literal("SetInBinSchema"), method_9527, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_17755, type_20238), Reflex::Literal("SplitCut"), method_9528, 0, "Cut;SplitVec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c, type_17755), Reflex::Literal("FormatCutList"), method_9529, 0, "Cut", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c, type_17755), Reflex::Literal("TranslateCut"), method_9530, 0, "Cut", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_9535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_9536, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_9537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_9538, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_9539, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_9540, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_9541, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_9542, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_9543, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_9544, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_9545, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_9546, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class WeightDataSetTool<TrackDataSet> -------------------------------
static  void operator_7292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::WeightDataSetTool<TrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<TrackDataSet>*)arg[0]);
  else   (((::WeightDataSetTool<TrackDataSet>*)o)->operator=)(*(const ::WeightDataSetTool<TrackDataSet>*)arg[0]);
}

static void constructor_7293( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<TrackDataSet>();
  else ::new(mem) ::WeightDataSetTool<TrackDataSet>();
}

static void constructor_7294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<TrackDataSet>((::TrackDataSet*)arg[0],
      (::TrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  else ::new(mem) ::WeightDataSetTool<TrackDataSet>((::TrackDataSet*)arg[0],
      (::TrackDataSet*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
}

static void constructor_7295( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::WeightDataSetTool<TrackDataSet>(*(const ::WeightDataSetTool<TrackDataSet>*)arg[0]);
  else ::new(mem) ::WeightDataSetTool<TrackDataSet>(*(const ::WeightDataSetTool<TrackDataSet>*)arg[0]);
}

static void destructor_7296(void*, void * o, const std::vector<void*>&, void *) {
(((::WeightDataSetTool<TrackDataSet>*)o)->::WeightDataSetTool<TrackDataSet>::~WeightDataSetTool)();
}
static  void method_7297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<TrackDataSet>*)o)->ref_data)());
  else   (((const ::WeightDataSetTool<TrackDataSet>*)o)->ref_data)();
}

static  void method_7298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::WeightDataSetTool<TrackDataSet>*)o)->cal_data)());
  else   (((const ::WeightDataSetTool<TrackDataSet>*)o)->cal_data)();
}

static  void method_7299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooBinning*>)((((const ::WeightDataSetTool<TrackDataSet>*)o)->bin_schema)());
  else   (((const ::WeightDataSetTool<TrackDataSet>*)o)->bin_schema)();
}

static  void method_7300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<TrackDataSet>*)o)->ANDInBins)());
    else     (((::WeightDataSetTool<TrackDataSet>*)o)->ANDInBins)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<TrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::WeightDataSetTool<TrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<TrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]));
    else     (((::WeightDataSetTool<TrackDataSet>*)o)->ANDInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
}

static  void method_7301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<TrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::WeightDataSetTool<TrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<TrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::WeightDataSetTool<TrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::WeightDataSetTool<TrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]));
    else     (((::WeightDataSetTool<TrackDataSet>*)o)->WeightInBins)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(const ::std::basic_string<char>*)arg[3]);
  }
}

static void method_newdel_1400( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<TrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<TrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<TrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<TrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::WeightDataSetTool<TrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class WeightDataSetTool<TrackDataSet> -------------------------------
void __WeightDataSetTool_TrackDataSet__db_datamem(Reflex::Class*);
void __WeightDataSetTool_TrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_TrackDataSet__datamem_bld(&__WeightDataSetTool_TrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __WeightDataSetTool_TrackDataSet__funcmem_bld(&__WeightDataSetTool_TrackDataSet__db_funcmem);
void __WeightDataSetTool_TrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("WeightDataSetTool<TrackDataSet>"), typeid(::WeightDataSetTool<TrackDataSet>), sizeof(::WeightDataSetTool<TrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "WeightDataSetTool<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18953, type_18954), Reflex::Literal("operator="), operator_7292, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightDataSetTool"), constructor_7293, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18952, type_18952, type_18631), Reflex::Literal("WeightDataSetTool"), constructor_7294, 0, "Ref;Cal;Bin", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18954), Reflex::Literal("WeightDataSetTool"), constructor_7295, 0, "tool", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightDataSetTool"), destructor_7296, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1400, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__WeightDataSetTool_TrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__WeightDataSetTool_TrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class WeightDataSetTool<TrackDataSet> -------------------
void __WeightDataSetTool_TrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18952, Reflex::Literal("m_RefData"), OffsetOf(__shadow__::__WeightDataSetTool_TrackDataSet_, m_RefData), ::Reflex::PRIVATE)
  .AddDataMember(type_18952, Reflex::Literal("m_CalData"), OffsetOf(__shadow__::__WeightDataSetTool_TrackDataSet_, m_CalData), ::Reflex::PRIVATE)
  .AddDataMember(type_2751, Reflex::Literal("m_BinSchema"), OffsetOf(__shadow__::__WeightDataSetTool_TrackDataSet_, m_BinSchema), ::Reflex::PRIVATE)
  .AddDataMember(type_600, Reflex::Literal("m_EmptyBinFlag"), OffsetOf(__shadow__::__WeightDataSetTool_TrackDataSet_, m_EmptyBinFlag), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class WeightDataSetTool<TrackDataSet> -------------------
void __WeightDataSetTool_TrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18952), Reflex::Literal("ref_data"), method_7297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18952), Reflex::Literal("cal_data"), method_7298, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2751), Reflex::Literal("bin_schema"), method_7299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_13041), Reflex::Literal("ANDInBins"), method_7300, 0, "WgtVar=\"\";WgtVar_Ref=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_13041, type_601, type_13041, type_13041), Reflex::Literal("WeightInBins"), method_7301, 0, "WgtVar;NormToSumEnties;WgtVar_Ref=\"\";WgtVar_Cal=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class LHCbPIDTrackDataSet -------------------------------
static void constructor_8684( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::LHCbPIDTrackDataSet*)arg[0]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::LHCbPIDTrackDataSet*)arg[0]);
}

static void constructor_8685( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet();
  else ::new(mem) ::LHCbPIDTrackDataSet();
}

static void constructor_8686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 18 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17]);
  }
  else if ( arg.size() == 19 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18]);
  }
  else if ( arg.size() == 20 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::RooDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5],
      *(const ::std::string*)arg[6],
      *(const ::std::string*)arg[7],
      *(const ::std::string*)arg[8],
      *(const ::std::string*)arg[9],
      *(const ::std::string*)arg[10],
      *(const ::std::string*)arg[11],
      *(const ::std::string*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::std::string*)arg[14],
      *(const ::std::string*)arg[15],
      *(const ::std::string*)arg[16],
      *(const ::std::string*)arg[17],
      *(const ::std::string*)arg[18],
      *(const ::std::string*)arg[19]);
  }
}

static void constructor_8687( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::LHCbPIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::LHCbPIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::LHCbPIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::LHCbPIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::LHCbPIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::LHCbPIDTrackDataSet(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      (::LHCbPIDTrackDataSet*)arg[2],
      *(const ::RooArgSet*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void destructor_8688(void*, void * o, const std::vector<void*>&, void *) {
(((::LHCbPIDTrackDataSet*)o)->::LHCbPIDTrackDataSet::~LHCbPIDTrackDataSet)();
}
static  void method_8689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHCbPIDTrackDataSet*)o)->append)(*(::LHCbPIDTrackDataSet*)arg[0]);
}

static  void method_8690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::LHCbPIDTrackDataSet*)o)->Get_ParamName_DLLe)());
  else   (((const ::LHCbPIDTrackDataSet*)o)->Get_ParamName_DLLe)();
}

static  void method_8691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::LHCbPIDTrackDataSet*)o)->Get_Param_DLLe)());
  else   (((const ::LHCbPIDTrackDataSet*)o)->Get_Param_DLLe)();
}

static  void method_8692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LHCbPIDTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]));
  else   (((::LHCbPIDTrackDataSet*)o)->SetInBinSchema)(*(::std::vector<RooBinning*>*)arg[0]);
}

static  void method_8695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LHCbPIDTrackDataSet*)o)->Class)());
  else   (((::LHCbPIDTrackDataSet*)o)->Class)();
}

static  void method_8696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LHCbPIDTrackDataSet*)o)->Class_Name)());
  else   (((::LHCbPIDTrackDataSet*)o)->Class_Name)();
}

static  void method_8697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::LHCbPIDTrackDataSet*)o)->Class_Version)());
  else   (((::LHCbPIDTrackDataSet*)o)->Class_Version)();
}

static  void method_8698( void*, void* o, const std::vector<void*>&, void*)
{
  (((::LHCbPIDTrackDataSet*)o)->Dictionary)();
}

static  void method_8699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::LHCbPIDTrackDataSet*)o)->IsA)());
  else   (((const ::LHCbPIDTrackDataSet*)o)->IsA)();
}

static  void method_8700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHCbPIDTrackDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_8701( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHCbPIDTrackDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_8702( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHCbPIDTrackDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_8703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LHCbPIDTrackDataSet*)o)->DeclFileName)());
  else   (((::LHCbPIDTrackDataSet*)o)->DeclFileName)();
}

static  void method_8704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::LHCbPIDTrackDataSet*)o)->ImplFileLine)());
  else   (((::LHCbPIDTrackDataSet*)o)->ImplFileLine)();
}

static  void method_8705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::LHCbPIDTrackDataSet*)o)->ImplFileName)());
  else   (((::LHCbPIDTrackDataSet*)o)->ImplFileName)();
}

static  void method_8706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::LHCbPIDTrackDataSet*)o)->DeclFileLine)());
  else   (((::LHCbPIDTrackDataSet*)o)->DeclFileLine)();
}

static void method_newdel_1763( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LHCbPIDTrackDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LHCbPIDTrackDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LHCbPIDTrackDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LHCbPIDTrackDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LHCbPIDTrackDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RICHTrackDataSet")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::RICHTrackDataSet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("EvtTrackDataSet")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::EvtTrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TrackDataSet")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::TrackDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::RooDataSet >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::RooAbsData >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::TNamed >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::TObject >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 6));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::RooPrintable >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::RooDirItem >::Get(),::Reflex::VIRTUAL |::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("MUONTrackDataSet")), ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet,::MUONTrackDataSet >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class LHCbPIDTrackDataSet -------------------------------
void __LHCbPIDTrackDataSet_db_datamem(Reflex::Class*);
void __LHCbPIDTrackDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LHCbPIDTrackDataSet_datamem_bld(&__LHCbPIDTrackDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __LHCbPIDTrackDataSet_funcmem_bld(&__LHCbPIDTrackDataSet_db_funcmem);
void __LHCbPIDTrackDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LHCbPIDTrackDataSet"), typeid(::LHCbPIDTrackDataSet), sizeof(::LHCbPIDTrackDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::LHCbPIDTrackDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_471, ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet, ::RICHTrackDataSet >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_700, ::Reflex::BaseOffset< ::LHCbPIDTrackDataSet, ::MUONTrackDataSet >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20164), Reflex::Literal("LHCbPIDTrackDataSet"), constructor_8684, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LHCbPIDTrackDataSet"), constructor_8685, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_18626, type_18462, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755, type_17755), Reflex::Literal("LHCbPIDTrackDataSet"), constructor_8686, 0, "TrackName;Charge;Data;vars;P_Name;PT_Name;ETA_Name;nTrack_Var;DLLK_Name;DLLp_Name;DLLe_Name;DLLmu_Name;IsMuon_Name;IsMuonLoose_Name;nShared_Name;ProbNNK_Name;ProbNNpi_Name;ProbNNp_Name;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_20165, type_18462, type_17755, type_17755), Reflex::Literal("LHCbPIDTrackDataSet"), constructor_8687, 0, "TrackName;Charge;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LHCbPIDTrackDataSet"), destructor_8688, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1763, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__LHCbPIDTrackDataSet_funcmem_bld);
}

//------Delayed data member builder for class LHCbPIDTrackDataSet -------------------
void __LHCbPIDTrackDataSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class LHCbPIDTrackDataSet -------------------
void __LHCbPIDTrackDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20166), Reflex::Literal("append"), method_8689, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c), Reflex::Literal("Get_ParamName_DLLe"), method_8690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630), Reflex::Literal("Get_Param_DLLe"), method_8691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_18631), Reflex::Literal("SetInBinSchema"), method_8692, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_8695, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_8696, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_8697, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_8698, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_8699, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_8700, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_8701, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_8702, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_8703, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_8704, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_8705, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_8706, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PIDTable -------------------------------
static  void operator_9018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PIDTable*)o)->operator=)(*(const ::PIDTable*)arg[0]);
  else   (((::PIDTable*)o)->operator=)(*(const ::PIDTable*)arg[0]);
}

static void constructor_9019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTable(*(const ::PIDTable*)arg[0]);
  else ::new(mem) ::PIDTable(*(const ::PIDTable*)arg[0]);
}

static void constructor_9020( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTable();
  else ::new(mem) ::PIDTable();
}

static void constructor_9021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTable((::TH1F*)arg[0],
      (::RooBinning*)arg[1]);
  else ::new(mem) ::PIDTable((::TH1F*)arg[0],
      (::RooBinning*)arg[1]);
}

static void constructor_9022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTable((::TH2F*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  else ::new(mem) ::PIDTable((::TH2F*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
}

static void constructor_9023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PIDTable((::TH3F*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  else ::new(mem) ::PIDTable((::TH3F*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
}

static  void method_9024( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::PIDTable*)o)->PrintTable)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::PIDTable*)o)->PrintTable)(*(::std::ostream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::PIDTable*)o)->PrintTable)(*(::std::ostream*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_9025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetPerfHist)((const ::TH1F*)arg[0]);
}

static  void method_9026( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetPerfHist)((const ::TH2F*)arg[0]);
}

static  void method_9027( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetPerfHist)((const ::TH3F*)arg[0]);
}

static  void method_9028( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::PIDTable*)o)->SetBinning)((const ::RooBinning*)arg[0],
      (const ::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::PIDTable*)o)->SetBinning)((const ::RooBinning*)arg[0],
      (const ::RooBinning*)arg[1],
      (const ::RooBinning*)arg[2]);
  }
}

static  void method_9029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetBinningX)((const ::RooBinning*)arg[0]);
}

static  void method_9030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetBinningY)((const ::RooBinning*)arg[0]);
}

static  void method_9031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetBinningZ)((const ::RooBinning*)arg[0]);
}

static  void method_9032( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetXTitle)((const char*)arg[0]);
}

static  void method_9033( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetYTitle)((const char*)arg[0]);
}

static  void method_9034( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetZTitle)((const char*)arg[0]);
}

static  void method_9035( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetEffTitle)((const char*)arg[0]);
}

static  void method_9036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetXUnit)((const char*)arg[0]);
}

static  void method_9037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetYUnit)((const char*)arg[0]);
}

static  void method_9038( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetZUnit)((const char*)arg[0]);
}

static  void method_9039( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetXPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_9040( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetYPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_9041( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetZPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_9042( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetEffPrecision)(*(::UInt_t*)arg[0]);
}

static  void method_9043( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetXScale)(*(::Double_t*)arg[0]);
}

static  void method_9044( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetYScale)(*(::Double_t*)arg[0]);
}

static  void method_9045( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetZScale)(*(::Double_t*)arg[0]);
}

static  void method_9046( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetXWidth)(*(::UInt_t*)arg[0]);
}

static  void method_9047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetYWidth)(*(::UInt_t*)arg[0]);
}

static  void method_9048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetZWidth)(*(::UInt_t*)arg[0]);
}

static  void method_9049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetEffWidth)(*(::UInt_t*)arg[0]);
}

static  void method_9050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetBit)(*(::PIDTable::Bit*)arg[0],
    *(::Bool_t*)arg[1]);
}

static  void method_9051( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetXAlignment)((const char*)arg[0]);
}

static  void method_9052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetYAlignment)((const char*)arg[0]);
}

static  void method_9053( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetZAlignment)((const char*)arg[0]);
}

static  void method_9054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetEffAlignment)((const char*)arg[0]);
}

static  void method_9055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetLabel)((const char*)arg[0]);
}

static  void method_9056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetCaption)((const char*)arg[0]);
}

static  void method_9057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetPositioning)((const char*)arg[0]);
}

static  void method_9058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PIDTable*)o)->SetSeparator)(*(::PIDTable::Separator*)arg[0],
    (const char*)arg[1]);
}

static  void method_9059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetPerfHist1D)());
  else   (((const ::PIDTable*)o)->GetPerfHist1D)();
}

static  void method_9060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetPerfHist2D)());
  else   (((const ::PIDTable*)o)->GetPerfHist2D)();
}

static  void method_9061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetPerfHist3D)());
  else   (((const ::PIDTable*)o)->GetPerfHist3D)();
}

static  void method_9062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetBinningX)());
  else   (((const ::PIDTable*)o)->GetBinningX)();
}

static  void method_9063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetBinningY)());
  else   (((const ::PIDTable*)o)->GetBinningY)();
}

static  void method_9064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetBinningZ)());
  else   (((const ::PIDTable*)o)->GetBinningZ)();
}

static  void method_9065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetXTitle)());
  else   (((const ::PIDTable*)o)->GetXTitle)();
}

static  void method_9066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetYTitle)());
  else   (((const ::PIDTable*)o)->GetYTitle)();
}

static  void method_9067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetZTitle)());
  else   (((const ::PIDTable*)o)->GetZTitle)();
}

static  void method_9068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetEffTitle)());
  else   (((const ::PIDTable*)o)->GetEffTitle)();
}

static  void method_9069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetXUnit)());
  else   (((const ::PIDTable*)o)->GetXUnit)();
}

static  void method_9070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetYUnit)());
  else   (((const ::PIDTable*)o)->GetYUnit)();
}

static  void method_9071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetZUnit)());
  else   (((const ::PIDTable*)o)->GetZUnit)();
}

static  void method_9072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetXPrecision)());
  else   (((const ::PIDTable*)o)->GetXPrecision)();
}

static  void method_9073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetYPrecision)());
  else   (((const ::PIDTable*)o)->GetYPrecision)();
}

static  void method_9074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetZPrecision)());
  else   (((const ::PIDTable*)o)->GetZPrecision)();
}

static  void method_9075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetEffPrecision)());
  else   (((const ::PIDTable*)o)->GetEffPrecision)();
}

static  void method_9076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::PIDTable*)o)->GetXScale)());
  else   (((const ::PIDTable*)o)->GetXScale)();
}

static  void method_9077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::PIDTable*)o)->GetYScale)());
  else   (((const ::PIDTable*)o)->GetYScale)();
}

static  void method_9078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::PIDTable*)o)->GetZScale)());
  else   (((const ::PIDTable*)o)->GetZScale)();
}

static  void method_9079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetXWidth)());
  else   (((const ::PIDTable*)o)->GetXWidth)();
}

static  void method_9080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetYWidth)());
  else   (((const ::PIDTable*)o)->GetYWidth)();
}

static  void method_9081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetZWidth)());
  else   (((const ::PIDTable*)o)->GetZWidth)();
}

static  void method_9082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::PIDTable*)o)->GetEffWidth)());
  else   (((const ::PIDTable*)o)->GetEffWidth)();
}

static  void method_9083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::PIDTable*)o)->GetBit)(*(::PIDTable::Bit*)arg[0]));
  else   (((const ::PIDTable*)o)->GetBit)(*(::PIDTable::Bit*)arg[0]);
}

static  void method_9084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetXAlignment)());
  else   (((const ::PIDTable*)o)->GetXAlignment)();
}

static  void method_9085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetYAlignment)());
  else   (((const ::PIDTable*)o)->GetYAlignment)();
}

static  void method_9086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetZAlignment)());
  else   (((const ::PIDTable*)o)->GetZAlignment)();
}

static  void method_9087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetEffAlignment)());
  else   (((const ::PIDTable*)o)->GetEffAlignment)();
}

static  void method_9088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetLabel)());
  else   (((const ::PIDTable*)o)->GetLabel)();
}

static  void method_9089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetCaption)());
  else   (((const ::PIDTable*)o)->GetCaption)();
}

static  void method_9090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetPositioning)());
  else   (((const ::PIDTable*)o)->GetPositioning)();
}

static  void method_9091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PIDTable*)o)->GetSeparator)(*(::PIDTable::Separator*)arg[0]));
  else   (((const ::PIDTable*)o)->GetSeparator)(*(::PIDTable::Separator*)arg[0]);
}

static void destructor_9092(void*, void * o, const std::vector<void*>&, void *) {
(((::PIDTable*)o)->::PIDTable::~PIDTable)();
}
static void method_newdel_1802( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PIDTable >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PIDTable >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PIDTable >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PIDTable >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PIDTable >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PIDTable -------------------------------
void __PIDTable_db_datamem(Reflex::Class*);
void __PIDTable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PIDTable_datamem_bld(&__PIDTable_db_datamem);
Reflex::GenreflexMemberBuilder __PIDTable_funcmem_bld(&__PIDTable_db_funcmem);
void __PIDTable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PIDTable"), typeid(::PIDTable), sizeof(::PIDTable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("PIDTable::Bit"), Reflex::Literal("ShowPercentage=0;SidewaysTable=1;ShowErrors=2"), &typeid(PIDTable::Bit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("PIDTable::Separator"), Reflex::Literal("Top=0;Bottom=1;Left=2;Right=3;Row=4;Column=5;Header=6"), &typeid(PIDTable::Separator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20189, type_20190), Reflex::Literal("operator="), operator_9018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20190), Reflex::Literal("PIDTable"), constructor_9019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PIDTable"), constructor_9020, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20121, type_12965), Reflex::Literal("PIDTable"), constructor_9021, 0, "perfHist;binsX", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18645, type_12965, type_12965), Reflex::Literal("PIDTable"), constructor_9022, 0, "perfHist;binsX;binsY", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20191, type_12965, type_12965, type_12965), Reflex::Literal("PIDTable"), constructor_9023, 0, "perfHist;binsX;binsY;binsZ", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PIDTable"), destructor_9092, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1802, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PIDTable_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PIDTable_funcmem_bld);
}

//------Delayed data member builder for class PIDTable -------------------
void __PIDTable_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20187, Reflex::Literal("m_perfHist1D"), OffsetOf(__shadow__::__PIDTable, m_perfHist1D), ::Reflex::PRIVATE)
  .AddDataMember(type_18641, Reflex::Literal("m_perfHist2D"), OffsetOf(__shadow__::__PIDTable, m_perfHist2D), ::Reflex::PRIVATE)
  .AddDataMember(type_20188, Reflex::Literal("m_perfHist3D"), OffsetOf(__shadow__::__PIDTable, m_perfHist3D), ::Reflex::PRIVATE)
  .AddDataMember(type_18642, Reflex::Literal("m_xBinning"), OffsetOf(__shadow__::__PIDTable, m_xBinning), ::Reflex::PRIVATE)
  .AddDataMember(type_18642, Reflex::Literal("m_yBinning"), OffsetOf(__shadow__::__PIDTable, m_yBinning), ::Reflex::PRIVATE)
  .AddDataMember(type_18642, Reflex::Literal("m_zBinning"), OffsetOf(__shadow__::__PIDTable, m_zBinning), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_xTitle"), OffsetOf(__shadow__::__PIDTable, m_xTitle), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_yTitle"), OffsetOf(__shadow__::__PIDTable, m_yTitle), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_zTitle"), OffsetOf(__shadow__::__PIDTable, m_zTitle), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_effTitle"), OffsetOf(__shadow__::__PIDTable, m_effTitle), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_xUnit"), OffsetOf(__shadow__::__PIDTable, m_xUnit), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_yUnit"), OffsetOf(__shadow__::__PIDTable, m_yUnit), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_zUnit"), OffsetOf(__shadow__::__PIDTable, m_zUnit), ::Reflex::PRIVATE)
  .AddDataMember(type_2077, Reflex::Literal("m_xScale"), OffsetOf(__shadow__::__PIDTable, m_xScale), ::Reflex::PRIVATE)
  .AddDataMember(type_2077, Reflex::Literal("m_yScale"), OffsetOf(__shadow__::__PIDTable, m_yScale), ::Reflex::PRIVATE)
  .AddDataMember(type_2077, Reflex::Literal("m_zScale"), OffsetOf(__shadow__::__PIDTable, m_zScale), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_showInPercent"), OffsetOf(__shadow__::__PIDTable, m_showInPercent), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_showErrors"), OffsetOf(__shadow__::__PIDTable, m_showErrors), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_xPrecision"), OffsetOf(__shadow__::__PIDTable, m_xPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_yPrecision"), OffsetOf(__shadow__::__PIDTable, m_yPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_zPrecision"), OffsetOf(__shadow__::__PIDTable, m_zPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_effPrecision"), OffsetOf(__shadow__::__PIDTable, m_effPrecision), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_xWidth"), OffsetOf(__shadow__::__PIDTable, m_xWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_yWidth"), OffsetOf(__shadow__::__PIDTable, m_yWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_zWidth"), OffsetOf(__shadow__::__PIDTable, m_zWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("m_effWidth"), OffsetOf(__shadow__::__PIDTable, m_effWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_label"), OffsetOf(__shadow__::__PIDTable, m_label), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_caption"), OffsetOf(__shadow__::__PIDTable, m_caption), ::Reflex::PRIVATE)
  .AddDataMember(type_601, Reflex::Literal("m_sidewaysTable"), OffsetOf(__shadow__::__PIDTable, m_sidewaysTable), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_xAlignment"), OffsetOf(__shadow__::__PIDTable, m_xAlignment), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_yAlignment"), OffsetOf(__shadow__::__PIDTable, m_yAlignment), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_zAlignment"), OffsetOf(__shadow__::__PIDTable, m_zAlignment), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_effAlignment"), OffsetOf(__shadow__::__PIDTable, m_effAlignment), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_positioning"), OffsetOf(__shadow__::__PIDTable, m_positioning), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_topSeparator"), OffsetOf(__shadow__::__PIDTable, m_topSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_bottomSeparator"), OffsetOf(__shadow__::__PIDTable, m_bottomSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_headerSeparator"), OffsetOf(__shadow__::__PIDTable, m_headerSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rowSeparator"), OffsetOf(__shadow__::__PIDTable, m_rowSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_leftSeparator"), OffsetOf(__shadow__::__PIDTable, m_leftSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_rightSeparator"), OffsetOf(__shadow__::__PIDTable, m_rightSeparator), ::Reflex::PRIVATE)
  .AddDataMember(type_3383, Reflex::Literal("m_colSeparator"), OffsetOf(__shadow__::__PIDTable, m_colSeparator), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PIDTable -------------------
void __PIDTable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_7167, type_601), Reflex::Literal("PrintTable"), method_9024, 0, "os=std::cout;useLaTeXFormat=kFALSE", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20187), Reflex::Literal("SetPerfHist"), method_9025, 0, "hist", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18641), Reflex::Literal("SetPerfHist"), method_9026, 0, "hist", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20188), Reflex::Literal("SetPerfHist"), method_9027, 0, "hist", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642, type_18642, type_18642), Reflex::Literal("SetBinning"), method_9028, 0, "binsX;binsY;binsZ=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642), Reflex::Literal("SetBinningX"), method_9029, 0, "bins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642), Reflex::Literal("SetBinningY"), method_9030, 0, "bins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18642), Reflex::Literal("SetBinningZ"), method_9031, 0, "bins", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetXTitle"), method_9032, 0, "title", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetYTitle"), method_9033, 0, "title", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetZTitle"), method_9034, 0, "title", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetEffTitle"), method_9035, 0, "title", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetXUnit"), method_9036, 0, "unit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetYUnit"), method_9037, 0, "unit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetZUnit"), method_9038, 0, "unit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetXPrecision"), method_9039, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetYPrecision"), method_9040, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetZPrecision"), method_9041, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetEffPrecision"), method_9042, 0, "precision", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2077), Reflex::Literal("SetXScale"), method_9043, 0, "scale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2077), Reflex::Literal("SetYScale"), method_9044, 0, "scale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2077), Reflex::Literal("SetZScale"), method_9045, 0, "scale", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetXWidth"), method_9046, 0, "width", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetYWidth"), method_9047, 0, "width", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetZWidth"), method_9048, 0, "width", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2552), Reflex::Literal("SetEffWidth"), method_9049, 0, "width", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_9016, type_601), Reflex::Literal("SetBit"), method_9050, 0, "flag;bit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetXAlignment"), method_9051, 0, "alignment", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetYAlignment"), method_9052, 0, "alignment", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetZAlignment"), method_9053, 0, "alignment", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetEffAlignment"), method_9054, 0, "alignment", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetLabel"), method_9055, 0, "label", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetCaption"), method_9056, 0, "caption", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3383), Reflex::Literal("SetPositioning"), method_9057, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_9017, type_3383), Reflex::Literal("SetSeparator"), method_9058, 0, "type;sep", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20187), Reflex::Literal("GetPerfHist1D"), method_9059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18641), Reflex::Literal("GetPerfHist2D"), method_9060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20188), Reflex::Literal("GetPerfHist3D"), method_9061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18642), Reflex::Literal("GetBinningX"), method_9062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18642), Reflex::Literal("GetBinningY"), method_9063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18642), Reflex::Literal("GetBinningZ"), method_9064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetXTitle"), method_9065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetYTitle"), method_9066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetZTitle"), method_9067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetEffTitle"), method_9068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetXUnit"), method_9069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetYUnit"), method_9070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetZUnit"), method_9071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetXPrecision"), method_9072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetYPrecision"), method_9073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetZPrecision"), method_9074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetEffPrecision"), method_9075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2077), Reflex::Literal("GetXScale"), method_9076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2077), Reflex::Literal("GetYScale"), method_9077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2077), Reflex::Literal("GetZScale"), method_9078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetXWidth"), method_9079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetYWidth"), method_9080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetZWidth"), method_9081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2552), Reflex::Literal("GetEffWidth"), method_9082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_601, type_9016), Reflex::Literal("GetBit"), method_9083, 0, "flag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetXAlignment"), method_9084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetYAlignment"), method_9085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetZAlignment"), method_9086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetEffAlignment"), method_9087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetLabel"), method_9088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetCaption"), method_9089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("GetPositioning"), method_9090, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383, type_9017), Reflex::Literal("GetSeparator"), method_9091, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_15486(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::basic_string<char> >*)o)->::std::pair<std::basic_string<char>,std::basic_string<char> >::~pair)();
}
static  void operator_15487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static void constructor_15488( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static void constructor_15489( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >();
}

static void constructor_15490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_2990( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__basic_string_char_s__datamem_bld(&__std__pair_std__basic_string_char__std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__basic_string_char_s__funcmem_bld(&__std__pair_std__basic_string_char__std__basic_string_char_s__db_funcmem);
void __std__pair_std__basic_string_char__std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >"), typeid(::std::pair<std::basic_string<char>,std::basic_string<char> >), sizeof(::std::pair<std::basic_string<char>,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2782, Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >::first_type"))
  .AddTypedef(type_2782, Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_15486, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9616, type_9618), Reflex::Literal("operator="), operator_15487, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9618), Reflex::Literal("pair"), constructor_15488, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_15489, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13041, type_13041), Reflex::Literal("pair"), constructor_15490, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2782, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__basic_string_char_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2782, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void constructor_9627( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >();
}

static void constructor_9628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void constructor_9629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[2]);
  }
}

static void constructor_9630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void destructor_9631(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::~vector)();
}
static  void operator_9632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_9633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_9634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_9635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_9636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_9637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_9642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->size)();
}

static  void method_9643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)();
}

static  void method_9644( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  }
}

static  void method_9645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->capacity)();
}

static  void method_9646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)();
}

static  void method_9647( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
}

static  void method_9654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
}

static  void method_9655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
}

static  void method_9656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
}

static  void method_9657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)();
}

static  void method_9658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)();
}

static  void method_9659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void method_9660( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->pop_back)();
}

static  void method_9661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_9662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[2]);
}

static  void method_9663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]);
}

static  void method_9664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]);
}

static  void method_9665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_9666( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->clear)();
}

static void method_newdel_1912( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >,::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"), typeid(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >), sizeof(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2729, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >, ::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2990, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_2729, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Base"))
  .AddTypedef(type_3107, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Tp_alloc_type"))
  .AddTypedef(type_8060, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Alloc_traits"))
  .AddTypedef(type_2990, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_9612, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_9614, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_9616, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::reference"))
  .AddTypedef(type_9618, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_7981, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_7982, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_3237, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_reverse_iterator"))
  .AddTypedef(type_3238, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_3087, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::size_type"))
  .AddTypedef(type_2840, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_3107, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9627, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20244), Reflex::Literal("vector"), constructor_9628, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3087, type_9618, type_20244), Reflex::Literal("vector"), constructor_9629, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20245), Reflex::Literal("vector"), constructor_9630, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9631, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1912, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20246, type_20245), Reflex::Literal("operator="), operator_9632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_9618), Reflex::Literal("assign"), method_9633, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981), Reflex::Literal("begin"), method_9634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7982), Reflex::Literal("begin"), method_9635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981), Reflex::Literal("end"), method_9636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7982), Reflex::Literal("end"), method_9637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("size"), method_9642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("max_size"), method_9643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_2990), Reflex::Literal("resize"), method_9644, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("capacity"), method_9645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_600), Reflex::Literal("empty"), method_9646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087), Reflex::Literal("reserve"), method_9647, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9616, type_3087), Reflex::Literal("operator[]"), operator_9648, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9618, type_3087), Reflex::Literal("operator[]"), operator_9649, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9616, type_3087), Reflex::Literal("at"), method_9651, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9618, type_3087), Reflex::Literal("at"), method_9652, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9616), Reflex::Literal("front"), method_9653, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9618), Reflex::Literal("front"), method_9654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9616), Reflex::Literal("back"), method_9655, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9618), Reflex::Literal("back"), method_9656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9612), Reflex::Literal("data"), method_9657, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9614), Reflex::Literal("data"), method_9658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_9618), Reflex::Literal("push_back"), method_9659, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("pop_back"), method_9660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981, type_7981, type_9618), Reflex::Literal("insert"), method_9661, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_7981, type_3087, type_9618), Reflex::Literal("insert"), method_9662, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981, type_7981), Reflex::Literal("erase"), method_9663, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7981, type_7981, type_7981), Reflex::Literal("erase"), method_9664, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20246), Reflex::Literal("swap"), method_9665, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("clear"), method_9666, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class GenericDataSet -------------------------------
static void constructor_9990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::GenericDataSet*)arg[0]);
  else ::new(mem) ::GenericDataSet(*(const ::GenericDataSet*)arg[0]);
}

static  void operator_9991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::GenericDataSet*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_9992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->operator new)(*(::size_t*)arg[0],
    (void*)arg[1]));
  else   (((::GenericDataSet*)o)->operator new)(*(::size_t*)arg[0],
    (void*)arg[1]);
}

static void constructor_9993( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet();
  else ::new(mem) ::GenericDataSet();
}

static void constructor_9994( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::RooDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::VectorOfStringPairs*)arg[3]);
  else ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::RooDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::VectorOfStringPairs*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::RooDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::VectorOfStringPairs*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::RooDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::VectorOfStringPairs*)arg[3],
      *(const ::std::string*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::RooDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::VectorOfStringPairs*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  else ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::RooDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::VectorOfStringPairs*)arg[3],
      *(const ::std::string*)arg[4],
      *(const ::std::string*)arg[5]);
  }
}

static void constructor_9995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::GenericDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2]);
  else ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::GenericDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::GenericDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::std::string*)arg[3]);
  else ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::GenericDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::std::string*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::GenericDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
  else ::new(mem) ::GenericDataSet(*(const ::std::string*)arg[0],
      (::GenericDataSet*)arg[1],
      *(const ::RooArgSet*)arg[2],
      *(const ::std::string*)arg[3],
      *(const ::std::string*)arg[4]);
  }
}

static void destructor_9996(void*, void * o, const std::vector<void*>&, void *) {
(((::GenericDataSet*)o)->::GenericDataSet::~GenericDataSet)();
}
static  void method_9997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenericDataSet*)o)->Get_Aliases)());
  else   (((const ::GenericDataSet*)o)->Get_Aliases)();
}

static  void method_9998( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericDataSet*)o)->append)(*(::GenericDataSet*)arg[0]);
}

static  void method_9999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::GenericDataSet*)o)->Get_ParamName)(*(const ::std::string*)arg[0]));
  else   (((const ::GenericDataSet*)o)->Get_ParamName)(*(const ::std::string*)arg[0]);
}

static  void method_10000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenericDataSet*)o)->Get_Param)(*(const ::std::string*)arg[0]));
  else   (((const ::GenericDataSet*)o)->Get_Param)(*(const ::std::string*)arg[0]);
}

static  void method_10001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->SetInBinSchema)(*(const ::std::vector<RooBinning*>*)arg[0]));
  else   (((::GenericDataSet*)o)->SetInBinSchema)(*(const ::std::vector<RooBinning*>*)arg[0]);
}

static  void method_10002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::string)((((::GenericDataSet*)o)->ReplaceVarNamesInCuts)(*(const ::std::string*)arg[0]));
    else     (((::GenericDataSet*)o)->ReplaceVarNamesInCuts)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::string)((((::GenericDataSet*)o)->ReplaceVarNamesInCuts)(*(const ::std::string*)arg[0],
      *(const ::VectorOfStringPairs*)arg[1]));
    else     (((::GenericDataSet*)o)->ReplaceVarNamesInCuts)(*(const ::std::string*)arg[0],
      *(const ::VectorOfStringPairs*)arg[1]);
  }
}

static  void method_10003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->reduce)((const char*)arg[0]));
  else   (((::GenericDataSet*)o)->reduce)((const char*)arg[0]);
}

static  void method_10004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->tree)());
  else   (((::GenericDataSet*)o)->tree)();
}

static  void method_10010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->Class)());
  else   (((::GenericDataSet*)o)->Class)();
}

static  void method_10011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->Class_Name)());
  else   (((::GenericDataSet*)o)->Class_Name)();
}

static  void method_10012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::GenericDataSet*)o)->Class_Version)());
  else   (((::GenericDataSet*)o)->Class_Version)();
}

static  void method_10013( void*, void* o, const std::vector<void*>&, void*)
{
  (((::GenericDataSet*)o)->Dictionary)();
}

static  void method_10014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenericDataSet*)o)->IsA)());
  else   (((const ::GenericDataSet*)o)->IsA)();
}

static  void method_10015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericDataSet*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericDataSet*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenericDataSet*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->DeclFileName)());
  else   (((::GenericDataSet*)o)->DeclFileName)();
}

static  void method_10019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::GenericDataSet*)o)->ImplFileLine)());
  else   (((::GenericDataSet*)o)->ImplFileLine)();
}

static  void method_10020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::GenericDataSet*)o)->ImplFileName)());
  else   (((::GenericDataSet*)o)->ImplFileName)();
}

static  void method_10021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::GenericDataSet*)o)->DeclFileLine)());
  else   (((::GenericDataSet*)o)->DeclFileLine)();
}

static void method_newdel_2102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenericDataSet >::new_np_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenericDataSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenericDataSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenericDataSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenericDataSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet")), ::Reflex::BaseOffset< ::GenericDataSet,::RooDataSet >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData")), ::Reflex::BaseOffset< ::GenericDataSet,::RooAbsData >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::GenericDataSet,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::GenericDataSet,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::GenericDataSet,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooDirItem")), ::Reflex::BaseOffset< ::GenericDataSet,::RooDirItem >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GenericDataSet -------------------------------
void __GenericDataSet_db_datamem(Reflex::Class*);
void __GenericDataSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenericDataSet_datamem_bld(&__GenericDataSet_db_datamem);
Reflex::GenreflexMemberBuilder __GenericDataSet_funcmem_bld(&__GenericDataSet_db_funcmem);
void __GenericDataSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenericDataSet"), typeid(::GenericDataSet), sizeof(::GenericDataSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::GenericDataSet::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1814, ::Reflex::BaseOffset< ::GenericDataSet, ::RooDataSet >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20382), Reflex::Literal("GenericDataSet"), constructor_9990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenericDataSet"), constructor_9993, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_18626, type_18462, type_20383, type_17755, type_17755), Reflex::Literal("GenericDataSet"), constructor_9994, 0, "TrackName;Data;vars;VarAliases;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_20384, type_18462, type_17755, type_17755), Reflex::Literal("GenericDataSet"), constructor_9995, 0, "TrackName;Data;vars;Cuts=\"\";WgtVarName=\"\"", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenericDataSet"), destructor_9996, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenericDataSet_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenericDataSet_funcmem_bld);
}

//------Delayed data member builder for class GenericDataSet -------------------
void __GenericDataSet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2917, Reflex::Literal("m_ParamMap"), OffsetOf(__shadow__::__GenericDataSet, m_ParamMap), ::Reflex::PRIVATE)
  .AddDataMember(type_1913c, Reflex::Literal("m_Aliases"), OffsetOf(__shadow__::__GenericDataSet, m_Aliases), ::Reflex::PRIVATE | ::Reflex::CONST);
}
//------Delayed function member builder for class GenericDataSet -------------------
void __GenericDataSet_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2447, type_1821), Reflex::Literal("operator new"), operator_9991, 0, "sz", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2447, type_1821, type_2447), Reflex::Literal("operator new"), operator_9992, 0, "sz;vp", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20385), Reflex::Literal("Get_Aliases"), method_9997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20386), Reflex::Literal("append"), method_9998, 0, "data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c, type_17755), Reflex::Literal("Get_ParamName"), method_9999, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18630, type_17755), Reflex::Literal("Get_Param"), method_10000, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_20237), Reflex::Literal("SetInBinSchema"), method_10001, 0, "BinSchema", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791c, type_17755, type_1913c), Reflex::Literal("ReplaceVarNamesInCuts"), method_10002, 0, "Cut;VarAliases=std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15004, type_3383), Reflex::Literal("reduce"), method_10003, 0, "cut", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6054), Reflex::Literal("tree"), method_10004, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_10010, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_10011, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_10012, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_10013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_10014, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_10015, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_10016, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_10017, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_10018, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_10019, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_10020, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_10021, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PerfCalculator<GenericDataSet> -------------------------------
static  void operator_10738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<GenericDataSet>*)o)->operator=)(*(const ::PerfCalculator<GenericDataSet>*)arg[0]);
  else   (((::PerfCalculator<GenericDataSet>*)o)->operator=)(*(const ::PerfCalculator<GenericDataSet>*)arg[0]);
}

static void constructor_10739( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<GenericDataSet>();
  else ::new(mem) ::PerfCalculator<GenericDataSet>();
}

static void constructor_10740( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<GenericDataSet>((::GenericDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<GenericDataSet>((::GenericDataSet*)arg[0]);
}

static void constructor_10741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<GenericDataSet>(*(const ::PerfCalculator<GenericDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<GenericDataSet>(*(const ::PerfCalculator<GenericDataSet>*)arg[0]);
}

static void destructor_10742(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<GenericDataSet>*)o)->::PerfCalculator<GenericDataSet>::~PerfCalculator)();
}
static  void method_10743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<GenericDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<GenericDataSet>*)o)->data)();
}

static  void method_10744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<GenericDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<GenericDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<GenericDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2375( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<GenericDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<GenericDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<GenericDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<GenericDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<GenericDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<GenericDataSet> -------------------------------
void __PerfCalculator_GenericDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_GenericDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_GenericDataSet__datamem_bld(&__PerfCalculator_GenericDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_GenericDataSet__funcmem_bld(&__PerfCalculator_GenericDataSet__db_funcmem);
void __PerfCalculator_GenericDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<GenericDataSet>"), typeid(::PerfCalculator<GenericDataSet>), sizeof(::PerfCalculator<GenericDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20511, type_20512), Reflex::Literal("operator="), operator_10738, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10739, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20384), Reflex::Literal("PerfCalculator"), constructor_10740, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20512), Reflex::Literal("PerfCalculator"), constructor_10741, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10742, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2375, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_GenericDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_GenericDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<GenericDataSet> -------------------
void __PerfCalculator_GenericDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20384, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_GenericDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<GenericDataSet> -------------------
void __PerfCalculator_GenericDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20384), Reflex::Literal("data"), method_10743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10744, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10745, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10746, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10747, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10748, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10749, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10750, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10751, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10752, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10753, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10754, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10755, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10756, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10757, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10758, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class PerfCalculator<LHCbPIDTrackDataSet> -------------------------------
static  void operator_10763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<LHCbPIDTrackDataSet>*)arg[0]);
  else   (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<LHCbPIDTrackDataSet>*)arg[0]);
}

static void constructor_10764( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<LHCbPIDTrackDataSet>();
  else ::new(mem) ::PerfCalculator<LHCbPIDTrackDataSet>();
}

static void constructor_10765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<LHCbPIDTrackDataSet>((::LHCbPIDTrackDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<LHCbPIDTrackDataSet>((::LHCbPIDTrackDataSet*)arg[0]);
}

static void constructor_10766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<LHCbPIDTrackDataSet>(*(const ::PerfCalculator<LHCbPIDTrackDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<LHCbPIDTrackDataSet>(*(const ::PerfCalculator<LHCbPIDTrackDataSet>*)arg[0]);
}

static void destructor_10767(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->::PerfCalculator<LHCbPIDTrackDataSet>::~PerfCalculator)();
}
static  void method_10768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<LHCbPIDTrackDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<LHCbPIDTrackDataSet>*)o)->data)();
}

static  void method_10769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<LHCbPIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2376( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<LHCbPIDTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<LHCbPIDTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<LHCbPIDTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<LHCbPIDTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<LHCbPIDTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<LHCbPIDTrackDataSet> -------------------------------
void __PerfCalculator_LHCbPIDTrackDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_LHCbPIDTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_LHCbPIDTrackDataSet__datamem_bld(&__PerfCalculator_LHCbPIDTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_LHCbPIDTrackDataSet__funcmem_bld(&__PerfCalculator_LHCbPIDTrackDataSet__db_funcmem);
void __PerfCalculator_LHCbPIDTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<LHCbPIDTrackDataSet>"), typeid(::PerfCalculator<LHCbPIDTrackDataSet>), sizeof(::PerfCalculator<LHCbPIDTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20519, type_20520), Reflex::Literal("operator="), operator_10763, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10764, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20165), Reflex::Literal("PerfCalculator"), constructor_10765, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20520), Reflex::Literal("PerfCalculator"), constructor_10766, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10767, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2376, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_LHCbPIDTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_LHCbPIDTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<LHCbPIDTrackDataSet> -------------------
void __PerfCalculator_LHCbPIDTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_20165, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_LHCbPIDTrackDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<LHCbPIDTrackDataSet> -------------------
void __PerfCalculator_LHCbPIDTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20165), Reflex::Literal("data"), method_10768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10769, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10770, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10771, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10772, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10773, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10774, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10775, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10776, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10777, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10778, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10779, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10780, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10781, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10782, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10783, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class PerfCalculator<PIDTrackDataSet> -------------------------------
static  void operator_10788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<PIDTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<PIDTrackDataSet>*)arg[0]);
  else   (((::PerfCalculator<PIDTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<PIDTrackDataSet>*)arg[0]);
}

static void constructor_10789( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<PIDTrackDataSet>();
  else ::new(mem) ::PerfCalculator<PIDTrackDataSet>();
}

static void constructor_10790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<PIDTrackDataSet>((::PIDTrackDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<PIDTrackDataSet>((::PIDTrackDataSet*)arg[0]);
}

static void constructor_10791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<PIDTrackDataSet>(*(const ::PerfCalculator<PIDTrackDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<PIDTrackDataSet>(*(const ::PerfCalculator<PIDTrackDataSet>*)arg[0]);
}

static void destructor_10792(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<PIDTrackDataSet>*)o)->::PerfCalculator<PIDTrackDataSet>::~PerfCalculator)();
}
static  void method_10793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<PIDTrackDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<PIDTrackDataSet>*)o)->data)();
}

static  void method_10794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<PIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<PIDTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2377( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<PIDTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<PIDTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<PIDTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<PIDTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<PIDTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<PIDTrackDataSet> -------------------------------
void __PerfCalculator_PIDTrackDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_PIDTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_PIDTrackDataSet__datamem_bld(&__PerfCalculator_PIDTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_PIDTrackDataSet__funcmem_bld(&__PerfCalculator_PIDTrackDataSet__db_funcmem);
void __PerfCalculator_PIDTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<PIDTrackDataSet>"), typeid(::PerfCalculator<PIDTrackDataSet>), sizeof(::PerfCalculator<PIDTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20521, type_20522), Reflex::Literal("operator="), operator_10788, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10789, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18791), Reflex::Literal("PerfCalculator"), constructor_10790, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20522), Reflex::Literal("PerfCalculator"), constructor_10791, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10792, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2377, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_PIDTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_PIDTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<PIDTrackDataSet> -------------------
void __PerfCalculator_PIDTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18791, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_PIDTrackDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<PIDTrackDataSet> -------------------
void __PerfCalculator_PIDTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18791), Reflex::Literal("data"), method_10793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10794, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10795, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10796, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10797, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10798, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10799, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10800, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10801, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10802, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10803, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10804, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10805, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10806, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10807, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10808, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class PerfCalculator<MUONTrackDataSet> -------------------------------
static  void operator_10813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<MUONTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<MUONTrackDataSet>*)arg[0]);
  else   (((::PerfCalculator<MUONTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<MUONTrackDataSet>*)arg[0]);
}

static void constructor_10814( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<MUONTrackDataSet>();
  else ::new(mem) ::PerfCalculator<MUONTrackDataSet>();
}

static void constructor_10815( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<MUONTrackDataSet>((::MUONTrackDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<MUONTrackDataSet>((::MUONTrackDataSet*)arg[0]);
}

static void constructor_10816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<MUONTrackDataSet>(*(const ::PerfCalculator<MUONTrackDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<MUONTrackDataSet>(*(const ::PerfCalculator<MUONTrackDataSet>*)arg[0]);
}

static void destructor_10817(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<MUONTrackDataSet>*)o)->::PerfCalculator<MUONTrackDataSet>::~PerfCalculator)();
}
static  void method_10818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<MUONTrackDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<MUONTrackDataSet>*)o)->data)();
}

static  void method_10819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<MUONTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<MUONTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2378( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<MUONTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<MUONTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<MUONTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<MUONTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<MUONTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<MUONTrackDataSet> -------------------------------
void __PerfCalculator_MUONTrackDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_MUONTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_MUONTrackDataSet__datamem_bld(&__PerfCalculator_MUONTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_MUONTrackDataSet__funcmem_bld(&__PerfCalculator_MUONTrackDataSet__db_funcmem);
void __PerfCalculator_MUONTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<MUONTrackDataSet>"), typeid(::PerfCalculator<MUONTrackDataSet>), sizeof(::PerfCalculator<MUONTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20523, type_20524), Reflex::Literal("operator="), operator_10813, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10814, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18708), Reflex::Literal("PerfCalculator"), constructor_10815, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20524), Reflex::Literal("PerfCalculator"), constructor_10816, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10817, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2378, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_MUONTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_MUONTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<MUONTrackDataSet> -------------------
void __PerfCalculator_MUONTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18708, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_MUONTrackDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<MUONTrackDataSet> -------------------
void __PerfCalculator_MUONTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18708), Reflex::Literal("data"), method_10818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10819, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10820, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10821, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10822, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10823, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10824, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10825, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10826, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10827, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10828, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10829, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10830, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10831, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10832, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10833, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class PerfCalculator<RICHTrackDataSet> -------------------------------
static  void operator_10838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<RICHTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<RICHTrackDataSet>*)arg[0]);
  else   (((::PerfCalculator<RICHTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<RICHTrackDataSet>*)arg[0]);
}

static void constructor_10839( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<RICHTrackDataSet>();
  else ::new(mem) ::PerfCalculator<RICHTrackDataSet>();
}

static void constructor_10840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<RICHTrackDataSet>((::RICHTrackDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<RICHTrackDataSet>((::RICHTrackDataSet*)arg[0]);
}

static void constructor_10841( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<RICHTrackDataSet>(*(const ::PerfCalculator<RICHTrackDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<RICHTrackDataSet>(*(const ::PerfCalculator<RICHTrackDataSet>*)arg[0]);
}

static void destructor_10842(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<RICHTrackDataSet>*)o)->::PerfCalculator<RICHTrackDataSet>::~PerfCalculator)();
}
static  void method_10843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<RICHTrackDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<RICHTrackDataSet>*)o)->data)();
}

static  void method_10844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<RICHTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<RICHTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2379( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<RICHTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<RICHTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<RICHTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<RICHTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<RICHTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<RICHTrackDataSet> -------------------------------
void __PerfCalculator_RICHTrackDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_RICHTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_RICHTrackDataSet__datamem_bld(&__PerfCalculator_RICHTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_RICHTrackDataSet__funcmem_bld(&__PerfCalculator_RICHTrackDataSet__db_funcmem);
void __PerfCalculator_RICHTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<RICHTrackDataSet>"), typeid(::PerfCalculator<RICHTrackDataSet>), sizeof(::PerfCalculator<RICHTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20525, type_20526), Reflex::Literal("operator="), operator_10838, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10839, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18627), Reflex::Literal("PerfCalculator"), constructor_10840, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20526), Reflex::Literal("PerfCalculator"), constructor_10841, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10842, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2379, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_RICHTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_RICHTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<RICHTrackDataSet> -------------------
void __PerfCalculator_RICHTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18627, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_RICHTrackDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<RICHTrackDataSet> -------------------
void __PerfCalculator_RICHTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18627), Reflex::Literal("data"), method_10843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10844, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10845, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10846, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10847, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10848, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10849, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10850, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10851, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10852, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10853, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10854, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10855, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10856, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10857, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10858, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class PerfCalculator<EvtTrackDataSet> -------------------------------
static  void operator_10863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<EvtTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<EvtTrackDataSet>*)arg[0]);
  else   (((::PerfCalculator<EvtTrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<EvtTrackDataSet>*)arg[0]);
}

static void constructor_10864( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<EvtTrackDataSet>();
  else ::new(mem) ::PerfCalculator<EvtTrackDataSet>();
}

static void constructor_10865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<EvtTrackDataSet>((::EvtTrackDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<EvtTrackDataSet>((::EvtTrackDataSet*)arg[0]);
}

static void constructor_10866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<EvtTrackDataSet>(*(const ::PerfCalculator<EvtTrackDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<EvtTrackDataSet>(*(const ::PerfCalculator<EvtTrackDataSet>*)arg[0]);
}

static void destructor_10867(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<EvtTrackDataSet>*)o)->::PerfCalculator<EvtTrackDataSet>::~PerfCalculator)();
}
static  void method_10868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<EvtTrackDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<EvtTrackDataSet>*)o)->data)();
}

static  void method_10869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<EvtTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<EvtTrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2380( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<EvtTrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<EvtTrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<EvtTrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<EvtTrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<EvtTrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<EvtTrackDataSet> -------------------------------
void __PerfCalculator_EvtTrackDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_EvtTrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_EvtTrackDataSet__datamem_bld(&__PerfCalculator_EvtTrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_EvtTrackDataSet__funcmem_bld(&__PerfCalculator_EvtTrackDataSet__db_funcmem);
void __PerfCalculator_EvtTrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<EvtTrackDataSet>"), typeid(::PerfCalculator<EvtTrackDataSet>), sizeof(::PerfCalculator<EvtTrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20527, type_20528), Reflex::Literal("operator="), operator_10863, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10864, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18949), Reflex::Literal("PerfCalculator"), constructor_10865, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20528), Reflex::Literal("PerfCalculator"), constructor_10866, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10867, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2380, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_EvtTrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_EvtTrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<EvtTrackDataSet> -------------------
void __PerfCalculator_EvtTrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18949, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_EvtTrackDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<EvtTrackDataSet> -------------------
void __PerfCalculator_EvtTrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18949), Reflex::Literal("data"), method_10868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10869, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10870, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10871, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10872, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10873, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10874, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10875, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10876, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10877, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10878, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10879, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10880, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10881, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10882, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10883, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class PerfCalculator<TrackDataSet> -------------------------------
static  void operator_10888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PerfCalculator<TrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<TrackDataSet>*)arg[0]);
  else   (((::PerfCalculator<TrackDataSet>*)o)->operator=)(*(const ::PerfCalculator<TrackDataSet>*)arg[0]);
}

static void constructor_10889( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<TrackDataSet>();
  else ::new(mem) ::PerfCalculator<TrackDataSet>();
}

static void constructor_10890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<TrackDataSet>((::TrackDataSet*)arg[0]);
  else ::new(mem) ::PerfCalculator<TrackDataSet>((::TrackDataSet*)arg[0]);
}

static void constructor_10891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PerfCalculator<TrackDataSet>(*(const ::PerfCalculator<TrackDataSet>*)arg[0]);
  else ::new(mem) ::PerfCalculator<TrackDataSet>(*(const ::PerfCalculator<TrackDataSet>*)arg[0]);
}

static void destructor_10892(void*, void * o, const std::vector<void*>&, void *) {
(((::PerfCalculator<TrackDataSet>*)o)->::PerfCalculator<TrackDataSet>::~PerfCalculator)();
}
static  void method_10893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PerfCalculator<TrackDataSet>*)o)->data)());
  else   (((const ::PerfCalculator<TrackDataSet>*)o)->data)();
}

static  void method_10894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (PIDResult)((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<PIDResult>)((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
}

static  void method_10896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Hist)((const char*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(::std::vector<RooBinning*>*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      *(::Bool_t*)arg[2],
      *(::Int_t*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_10898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]));
  else   (((::PerfCalculator<TrackDataSet>*)o)->Perf_BayesErrors)(*(const ::std::basic_string<char>*)arg[0],
    (::RooBinning*)arg[1]);
}

static  void method_10899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::list<std::basic_string<char> >*)arg[0],
      *(::Bool_t*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_10900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_10901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_Scan_ToFile)(*(const ::std::vector<PIDResult>*)arg[0],
      *(const ::std::list<std::basic_string<char> >*)arg[1],
      *(const ::std::basic_string<char>*)arg[2],
      *(::Bool_t*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_10902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static  void method_10903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static  void method_10904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Perf_TEff)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
}

static  void method_10905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::std::basic_ostream<char,std::char_traits<char> >*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Int_t*)arg[6]);
  }
}

static  void method_10906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static  void method_10907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->Table)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      (::RooBinning*)arg[3],
      *(::Bool_t*)arg[4],
      *(::Int_t*)arg[5]);
  }
}

static  void method_10908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PerfCalculator<TrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]));
    else     (((::PerfCalculator<TrackDataSet>*)o)->CrossTable)(*(const ::std::basic_string<char>*)arg[0],
      (::RooBinning*)arg[1],
      (::RooBinning*)arg[2],
      *(::Bool_t*)arg[3],
      *(::Int_t*)arg[4]);
  }
}

static void method_newdel_2381( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PerfCalculator<TrackDataSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PerfCalculator<TrackDataSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PerfCalculator<TrackDataSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PerfCalculator<TrackDataSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PerfCalculator<TrackDataSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PerfCalculator<TrackDataSet> -------------------------------
void __PerfCalculator_TrackDataSet__db_datamem(Reflex::Class*);
void __PerfCalculator_TrackDataSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PerfCalculator_TrackDataSet__datamem_bld(&__PerfCalculator_TrackDataSet__db_datamem);
Reflex::GenreflexMemberBuilder __PerfCalculator_TrackDataSet__funcmem_bld(&__PerfCalculator_TrackDataSet__db_funcmem);
void __PerfCalculator_TrackDataSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PerfCalculator<TrackDataSet>"), typeid(::PerfCalculator<TrackDataSet>), sizeof(::PerfCalculator<TrackDataSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "PerfCalculator<*>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20529, type_20530), Reflex::Literal("operator="), operator_10888, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PerfCalculator"), constructor_10889, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18952), Reflex::Literal("PerfCalculator"), constructor_10890, 0, "Data", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20530), Reflex::Literal("PerfCalculator"), constructor_10891, 0, "perf", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PerfCalculator"), destructor_10892, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2381, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PerfCalculator_TrackDataSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PerfCalculator_TrackDataSet__funcmem_bld);
}

//------Delayed data member builder for class PerfCalculator<TrackDataSet> -------------------
void __PerfCalculator_TrackDataSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_18952, Reflex::Literal("m_Data"), OffsetOf(__shadow__::__PerfCalculator_TrackDataSet_, m_Data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PerfCalculator<TrackDataSet> -------------------
void __PerfCalculator_TrackDataSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18952), Reflex::Literal("data"), method_10893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1152, type_13041, type_601), Reflex::Literal("Perf"), method_10894, 0, "PIDCut;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_20513, type_601), Reflex::Literal("Perf"), method_10895, 0, "PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12078, type_3383, type_13041, type_18631, type_601, type_1165, type_601), Reflex::Literal("Perf_Hist"), method_10896, 0, "histName;pidCut;theBinSchema;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121, type_13041, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10897, 0, "PIDCut;BinScheme;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_13041, type_12965), Reflex::Literal("Perf_BayesErrors"), method_10898, 0, "PIDCut;", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20513, type_601, type_133), Reflex::Literal("Perf_Scan"), method_10899, 0, "Cuts;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_601), Reflex::Literal("Perf_Scan"), method_10900, 0, "Ex_Results;PIDCuts;BayesErrors=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009, type_20514, type_20513, type_13041, type_601, type_133), Reflex::Literal("Perf_Scan_ToFile"), method_10901, 0, "Ex_Results;PIDCuts;FileName;BayesErrors=kTRUE;index=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18645, type_13041, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10902, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_601, type_1165, type_601), Reflex::Literal("Perf"), method_10903, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5;printVals=kFALSE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20515, type_13041, type_12965, type_12965, type_12965), Reflex::Literal("Perf_TEff"), method_10904, 0, "PIDCut;xBinning;yBinning=0l;zBinning=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20191, type_13041, type_12965, type_12965, type_12965, type_12937, type_601, type_1165), Reflex::Literal("Table"), method_10905, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;os;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10906, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516, type_13041, type_12965, type_12965, type_12965, type_601, type_1165), Reflex::Literal("Table"), method_10907, 0, "PIDCut;BinSchema1;BinSchema2;BinSchema3;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517, type_13041, type_12965, type_12965, type_601, type_1165), Reflex::Literal("CrossTable"), method_10908, 0, "PIDCut;BinSchema1;BinSchema2;rejectNonNormalBins=kFALSE;minEntries=5", ::Reflex::PUBLIC);
}
//------Stub functions for class TrkPIDParams -------------------------------
static  void operator_11071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TrkPIDParams*)o)->operator=)(*(const ::TrkPIDParams*)arg[0]);
  else   (((::TrkPIDParams*)o)->operator=)(*(const ::TrkPIDParams*)arg[0]);
}

static void constructor_11072( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TrkPIDParams(*(const ::TrkPIDParams*)arg[0]);
  else ::new(mem) ::TrkPIDParams(*(const ::TrkPIDParams*)arg[0]);
}

static void constructor_11073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrkPIDParams();
  else ::new(mem) ::TrkPIDParams();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrkPIDParams(*(::Float_t*)arg[0]);
  else ::new(mem) ::TrkPIDParams(*(::Float_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrkPIDParams(*(::Float_t*)arg[0],
      *(::Float_t*)arg[1]);
  else ::new(mem) ::TrkPIDParams(*(::Float_t*)arg[0],
      *(::Float_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TrkPIDParams(*(::Float_t*)arg[0],
      *(::Float_t*)arg[1],
      *(::Int_t*)arg[2]);
  else ::new(mem) ::TrkPIDParams(*(::Float_t*)arg[0],
      *(::Float_t*)arg[1],
      *(::Int_t*)arg[2]);
  }
}

static void destructor_11074(void*, void * o, const std::vector<void*>&, void *) {
(((::TrkPIDParams*)o)->::TrkPIDParams::~TrkPIDParams)();
}
static void constructor_x34( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TrkPIDParams();
  else ::new(mem) ::TrkPIDParams();
}

static void method_newdel_2455( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TrkPIDParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TrkPIDParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TrkPIDParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TrkPIDParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TrkPIDParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TrkPIDParams -------------------------------
void __TrkPIDParams_db_datamem(Reflex::Class*);
void __TrkPIDParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TrkPIDParams_datamem_bld(&__TrkPIDParams_db_datamem);
Reflex::GenreflexMemberBuilder __TrkPIDParams_funcmem_bld(&__TrkPIDParams_db_funcmem);
void __TrkPIDParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TrkPIDParams"), typeid(::TrkPIDParams), sizeof(::TrkPIDParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20537, type_20538), Reflex::Literal("operator="), operator_11071, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20538), Reflex::Literal("TrkPIDParams"), constructor_11072, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2261, type_2261, type_1165), Reflex::Literal("TrkPIDParams"), constructor_11073, 0, "a=0;b=0;c=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TrkPIDParams"), destructor_11074, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TrkPIDParams"), constructor_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2455, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TrkPIDParams_datamem_bld);
}

//------Delayed data member builder for class TrkPIDParams -------------------
void __TrkPIDParams_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2261, Reflex::Literal("TrkPIDEff"), OffsetOf(__shadow__::__TrkPIDParams, TrkPIDEff), ::Reflex::PUBLIC)
  .AddDataMember(type_2261, Reflex::Literal("TrkPIDErr"), OffsetOf(__shadow__::__TrkPIDParams, TrkPIDErr), ::Reflex::PUBLIC)
  .AddDataMember(type_2261, Reflex::Literal("TrkPIDEffWeight"), OffsetOf(__shadow__::__TrkPIDParams, TrkPIDEffWeight), ::Reflex::PUBLIC)
  .AddDataMember(type_2261, Reflex::Literal("TrkPIDErrWeight"), OffsetOf(__shadow__::__TrkPIDParams, TrkPIDErrWeight), ::Reflex::PUBLIC)
  .AddDataMember(type_1165, Reflex::Literal("TrkBinNumber"), OffsetOf(__shadow__::__TrkPIDParams, TrkBinNumber), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TrkPIDParams -------------------
void __TrkPIDParams_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DataBinCuts -------------------------------
static  void operator_11370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DataBinCuts*)o)->operator=)(*(const ::DataBinCuts*)arg[0]);
  else   (((::DataBinCuts*)o)->operator=)(*(const ::DataBinCuts*)arg[0]);
}

static void constructor_11371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DataBinCuts(*(const ::DataBinCuts*)arg[0]);
  else ::new(mem) ::DataBinCuts(*(const ::DataBinCuts*)arg[0]);
}

static void constructor_11372( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DataBinCuts();
  else ::new(mem) ::DataBinCuts();
}

static void constructor_11373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DataBinCuts(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[2]);
  else ::new(mem) ::DataBinCuts(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[2]);
}

static void destructor_11374(void*, void * o, const std::vector<void*>&, void *) {
(((::DataBinCuts*)o)->::DataBinCuts::~DataBinCuts)();
}
static  void method_11375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TCut)((((::DataBinCuts*)o)->GetCuts)(*(const ::std::list<int>*)arg[0]));
  else   (((::DataBinCuts*)o)->GetCuts)(*(const ::std::list<int>*)arg[0]);
}

static  void method_11376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TCut)((((::DataBinCuts*)o)->GetGlobalCuts)());
  else   (((::DataBinCuts*)o)->GetGlobalCuts)();
}

static  void method_11377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DataBinCuts*)o)->Class)());
  else   (((::DataBinCuts*)o)->Class)();
}

static  void method_11378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DataBinCuts*)o)->Class_Name)());
  else   (((::DataBinCuts*)o)->Class_Name)();
}

static  void method_11379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::DataBinCuts*)o)->Class_Version)());
  else   (((::DataBinCuts*)o)->Class_Version)();
}

static  void method_11380( void*, void* o, const std::vector<void*>&, void*)
{
  (((::DataBinCuts*)o)->Dictionary)();
}

static  void method_11381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DataBinCuts*)o)->IsA)());
  else   (((const ::DataBinCuts*)o)->IsA)();
}

static  void method_11382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DataBinCuts*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11383( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DataBinCuts*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11384( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DataBinCuts*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DataBinCuts*)o)->DeclFileName)());
  else   (((::DataBinCuts*)o)->DeclFileName)();
}

static  void method_11386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DataBinCuts*)o)->ImplFileLine)());
  else   (((::DataBinCuts*)o)->ImplFileLine)();
}

static  void method_11387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DataBinCuts*)o)->ImplFileName)());
  else   (((::DataBinCuts*)o)->ImplFileName)();
}

static  void method_11388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DataBinCuts*)o)->DeclFileLine)());
  else   (((::DataBinCuts*)o)->DeclFileLine)();
}

static void method_newdel_2503( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DataBinCuts >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DataBinCuts >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DataBinCuts >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DataBinCuts >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DataBinCuts >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::DataBinCuts,::TNamed >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::DataBinCuts,::TObject >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DataBinCuts -------------------------------
void __DataBinCuts_db_datamem(Reflex::Class*);
void __DataBinCuts_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DataBinCuts_datamem_bld(&__DataBinCuts_db_datamem);
Reflex::GenreflexMemberBuilder __DataBinCuts_funcmem_bld(&__DataBinCuts_db_funcmem);
void __DataBinCuts_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DataBinCuts"), typeid(::DataBinCuts), sizeof(::DataBinCuts), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::DataBinCuts::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2553, ::Reflex::BaseOffset< ::DataBinCuts, ::TNamed >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20582, type_20583), Reflex::Literal("operator="), operator_11370, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20583), Reflex::Literal("DataBinCuts"), constructor_11371, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DataBinCuts"), constructor_11372, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17755, type_17755, type_20584), Reflex::Literal("DataBinCuts"), constructor_11373, 0, "Name;Title;BinList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DataBinCuts"), destructor_11374, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2503, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DataBinCuts_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DataBinCuts_funcmem_bld);
}

//------Delayed data member builder for class DataBinCuts -------------------
void __DataBinCuts_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2711, Reflex::Literal("m_BinDefs"), OffsetOf(__shadow__::__DataBinCuts, m_BinDefs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DataBinCuts -------------------
void __DataBinCuts_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1418c, type_20585), Reflex::Literal("GetCuts"), method_11375, 0, "BinIndex", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1418c), Reflex::Literal("GetGlobalCuts"), method_11376, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("Class"), method_11377, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("Class_Name"), method_11378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("Class_Version"), method_11379, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("Dictionary"), method_11380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("IsA"), method_11381, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18477), Reflex::Literal("ShowMembers"), method_11382, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("Streamer"), method_11383, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_4831), Reflex::Literal("StreamerNVirtual"), method_11384, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("DeclFileName"), method_11385, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("ImplFileLine"), method_11386, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3383), Reflex::Literal("ImplFileName"), method_11387, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("DeclFileLine"), method_11388, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooBinning*> -------------------------------
static void destructor_15495(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,RooBinning*>*)o)->::std::pair<std::basic_string<char>,RooBinning*>::~pair)();
}
static  void operator_15496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,RooBinning*>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,RooBinning*>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
}

static void constructor_15497( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooBinning*>(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,RooBinning*>(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
}

static void constructor_15498( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooBinning*>();
  else ::new(mem) ::std::pair<std::basic_string<char>,RooBinning*>();
}

static void constructor_15499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooBinning*>(*(const ::std::basic_string<char>*)arg[0],
      *(::RooBinning* const*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,RooBinning*>(*(const ::std::basic_string<char>*)arg[0],
      *(::RooBinning* const*)arg[1]);
}

static void method_newdel_2991( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooBinning*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooBinning*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooBinning*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooBinning*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooBinning*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooBinning*> -------------------------------
void __std__pair_std__basic_string_char__RooBinningp__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__RooBinningp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__RooBinningp__datamem_bld(&__std__pair_std__basic_string_char__RooBinningp__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__RooBinningp__funcmem_bld(&__std__pair_std__basic_string_char__RooBinningp__db_funcmem);
void __std__pair_std__basic_string_char__RooBinningp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,RooBinning*>"), typeid(::std::pair<std::basic_string<char>,RooBinning*>), sizeof(::std::pair<std::basic_string<char>,RooBinning*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2782, Reflex::Literal("std::pair<std::basic_string<char>,RooBinning*>::first_type"))
  .AddTypedef(type_12965, Reflex::Literal("std::pair<std::basic_string<char>,RooBinning*>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_15495, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12557, type_12559), Reflex::Literal("operator="), operator_15496, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12559), Reflex::Literal("pair"), constructor_15497, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_15498, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13041, type_12976), Reflex::Literal("pair"), constructor_15499, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2991, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__RooBinningp__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooBinning*> -------------------
void __std__pair_std__basic_string_char__RooBinningp__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2782, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__RooBinningp_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_12965, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__RooBinningp_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooBinning*> -------------------
void __std__pair_std__basic_string_char__RooBinningp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class list<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*> > > -------------------------------
static void destructor_12569(void*, void * o, const std::vector<void*>&, void *) {
(((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->::std::list<std::pair<std::basic_string<char>,RooBinning*> >::~list)();
}
static void constructor_12571( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >();
  else ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >();
}

static void constructor_12572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(const ::std::allocator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
  else ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(const ::std::allocator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
}

static void constructor_12573( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1]);
  else ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[2]);
  else ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[2]);
  }
}

static void constructor_12574( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
  else ::new(mem) ::std::list<std::pair<std::basic_string<char>,RooBinning*> >(*(const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
}

static  void operator_12575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->operator=)(*(const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->operator=)(*(const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
}

static  void method_12576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1]);
}

static  void method_12577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<std::basic_string<char>,RooBinning*> >)((((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->get_allocator)());
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->get_allocator)();
}

static  void method_12578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->begin)());
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->begin)();
}

static  void method_12579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_const_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->begin)());
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->begin)();
}

static  void method_12580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->end)());
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->end)();
}

static  void method_12581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_const_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->end)());
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->end)();
}

static  void method_12586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->empty)());
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->empty)();
}

static  void method_12587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->size)());
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->size)();
}

static  void method_12588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->max_size)());
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->max_size)();
}

static  void method_12589( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,RooBinning*>*)arg[1]);
  }
}

static  void method_12590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->front)();
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->front)();
}

static  void method_12591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->front)();
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->front)();
}

static  void method_12592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->back)();
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->back)();
}

static  void method_12593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->back)();
  else   (((const ::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->back)();
}

static  void method_12594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->push_front)(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
}

static  void method_12595( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->pop_front)();
}

static  void method_12596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
}

static  void method_12597( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->pop_back)();
}

static  void method_12598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->insert)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1]));
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->insert)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[1]);
}

static  void method_12599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->insert)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[2]);
}

static  void method_12600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->erase)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]));
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->erase)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
}

static  void method_12601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >)((((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->erase)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[1]));
  else   (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->erase)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[1]);
}

static  void method_12602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->swap)(*(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
}

static  void method_12603( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->clear)();
}

static  void method_12604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->splice)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[1]);
}

static  void method_12605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->splice)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[1],
    *(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[2]);
}

static  void method_12606( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->splice)(*(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0],
    *(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[1],
    *(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[2],
    *(::std::_List_iterator<std::pair<std::basic_string<char>,RooBinning*> >*)arg[3]);
}

static  void method_12607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->remove)(*(const ::std::pair<std::basic_string<char>,RooBinning*>*)arg[0]);
}

static  void method_12608( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->unique)();
}

static  void method_12609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->merge)(*(::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)arg[0]);
}

static  void method_12610( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->reverse)();
}

static  void method_12611( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<std::pair<std::basic_string<char>,RooBinning*> >*)o)->sort)();
}

static void method_newdel_2711( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_List_base<std::pair<std::basic_string<char>,RooBinning*>,std::allocator<std::pair<std::basic_string<char>,RooBinning*> > >")), ::Reflex::BaseOffset< ::std::list<std::pair<std::basic_string<char>,RooBinning*> >,::std::_List_base<std::pair<std::basic_string<char>,RooBinning*>,std::allocator<std::pair<std::basic_string<char>,RooBinning*> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::Generate();
  else ::Reflex::Proxy< ::std::list<std::pair<std::basic_string<char>,RooBinning*> > >::Generate();
}

//------Dictionary for class list<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*> > > -------------------------------
void __std__list_std__pair_std__basic_string_char__RooBinningp_s__db_datamem(Reflex::Class*);
void __std__list_std__pair_std__basic_string_char__RooBinningp_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__list_std__pair_std__basic_string_char__RooBinningp_s__datamem_bld(&__std__list_std__pair_std__basic_string_char__RooBinningp_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__list_std__pair_std__basic_string_char__RooBinningp_s__funcmem_bld(&__std__list_std__pair_std__basic_string_char__RooBinningp_s__db_funcmem);
void __std__list_std__pair_std__basic_string_char__RooBinningp_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >"), typeid(::std::list<std::pair<std::basic_string<char>,RooBinning*> >), sizeof(::std::list<std::pair<std::basic_string<char>,RooBinning*> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3073, ::Reflex::BaseOffset< ::std::list<std::pair<std::basic_string<char>,RooBinning*> >, ::std::_List_base<std::pair<std::basic_string<char>,RooBinning*>,std::allocator<std::pair<std::basic_string<char>,RooBinning*> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2991, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::_Alloc_value_type"))
  .AddTypedef(type_3073, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::_Base"))
  .AddTypedef(type_3113, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::_Tp_alloc_type"))
  .AddTypedef(type_3130, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::_Node_alloc_type"))
  .AddTypedef(type_2991, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::value_type"))
  .AddTypedef(type_12553, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::pointer"))
  .AddTypedef(type_12555, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::const_pointer"))
  .AddTypedef(type_12557, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::reference"))
  .AddTypedef(type_12559, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::const_reference"))
  .AddTypedef(type_2955, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::iterator"))
  .AddTypedef(type_2708, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::const_iterator"))
  .AddTypedef(type_3245, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::const_reverse_iterator"))
  .AddTypedef(type_3246, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::reverse_iterator"))
  .AddTypedef(type_3087, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::size_type"))
  .AddTypedef(type_2840, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::difference_type"))
  .AddTypedef(type_3113, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::allocator_type"))
  .AddTypedef(type_3076, Reflex::Literal("std::list<std::pair<std::basic_string<char>,RooBinning*> >::_Node"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~list"), destructor_12569, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("list"), constructor_12571, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20666), Reflex::Literal("list"), constructor_12572, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3087, type_12559, type_20666), Reflex::Literal("list"), constructor_12573, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20667), Reflex::Literal("list"), constructor_12574, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2711, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__list_std__pair_std__basic_string_char__RooBinningp_s__funcmem_bld);
}

//------Delayed data member builder for class list<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*> > > -------------------
void __std__list_std__pair_std__basic_string_char__RooBinningp_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class list<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, RooBinning*> > > -------------------
void __std__list_std__pair_std__basic_string_char__RooBinningp_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20584, type_20667), Reflex::Literal("operator="), operator_12575, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_12559), Reflex::Literal("assign"), method_12576, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3113), Reflex::Literal("get_allocator"), method_12577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2955), Reflex::Literal("begin"), method_12578, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2708), Reflex::Literal("begin"), method_12579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2955), Reflex::Literal("end"), method_12580, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2708), Reflex::Literal("end"), method_12581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_600), Reflex::Literal("empty"), method_12586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("size"), method_12587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("max_size"), method_12588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_2991), Reflex::Literal("resize"), method_12589, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12557), Reflex::Literal("front"), method_12590, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12559), Reflex::Literal("front"), method_12591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12557), Reflex::Literal("back"), method_12592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12559), Reflex::Literal("back"), method_12593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_12559), Reflex::Literal("push_front"), method_12594, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("pop_front"), method_12595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_12559), Reflex::Literal("push_back"), method_12596, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("pop_back"), method_12597, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2955, type_2955, type_12559), Reflex::Literal("insert"), method_12598, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2955, type_3087, type_12559), Reflex::Literal("insert"), method_12599, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2955, type_2955), Reflex::Literal("erase"), method_12600, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2955, type_2955, type_2955), Reflex::Literal("erase"), method_12601, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20584), Reflex::Literal("swap"), method_12602, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("clear"), method_12603, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2955, type_20584), Reflex::Literal("splice"), method_12604, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2955, type_20584, type_2955), Reflex::Literal("splice"), method_12605, 0, "__position;__x;__i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_2955, type_20584, type_2955, type_2955), Reflex::Literal("splice"), method_12606, 0, "__position;__x;__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_12559), Reflex::Literal("remove"), method_12607, 0, "__value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("unique"), method_12608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20584), Reflex::Literal("merge"), method_12609, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("reverse"), method_12610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("sort"), method_12611, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooBinning*,std::allocator<RooBinning*> > -------------------------------
static void constructor_12985( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooBinning*>();
  else ::new(mem) ::std::vector<RooBinning*>();
}

static void constructor_12986( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooBinning*>(*(const ::std::allocator<RooBinning*>*)arg[0]);
  else ::new(mem) ::std::vector<RooBinning*>(*(const ::std::allocator<RooBinning*>*)arg[0]);
}

static void constructor_12987( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooBinning*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooBinning*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooBinning*>(*(::std::size_t*)arg[0],
      *(::RooBinning* const*)arg[1]);
  else ::new(mem) ::std::vector<RooBinning*>(*(::std::size_t*)arg[0],
      *(::RooBinning* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooBinning*>(*(::std::size_t*)arg[0],
      *(::RooBinning* const*)arg[1],
      *(const ::std::allocator<RooBinning*>*)arg[2]);
  else ::new(mem) ::std::vector<RooBinning*>(*(::std::size_t*)arg[0],
      *(::RooBinning* const*)arg[1],
      *(const ::std::allocator<RooBinning*>*)arg[2]);
  }
}

static void constructor_12988( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooBinning*>(*(const ::std::vector<RooBinning*>*)arg[0]);
  else ::new(mem) ::std::vector<RooBinning*>(*(const ::std::vector<RooBinning*>*)arg[0]);
}

static void destructor_12989(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooBinning*>*)o)->::std::vector<RooBinning*>::~vector)();
}
static  void operator_12990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooBinning*>*)o)->operator=)(*(const ::std::vector<RooBinning*>*)arg[0]);
  else   (((::std::vector<RooBinning*>*)o)->operator=)(*(const ::std::vector<RooBinning*>*)arg[0]);
}

static  void method_12991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooBinning*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooBinning* const*)arg[1]);
}

static  void method_12992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >)((((::std::vector<RooBinning*>*)o)->begin)());
  else   (((::std::vector<RooBinning*>*)o)->begin)();
}

static  void method_12993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning* const*,std::vector<RooBinning*> >)((((const ::std::vector<RooBinning*>*)o)->begin)());
  else   (((const ::std::vector<RooBinning*>*)o)->begin)();
}

static  void method_12994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >)((((::std::vector<RooBinning*>*)o)->end)());
  else   (((::std::vector<RooBinning*>*)o)->end)();
}

static  void method_12995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning* const*,std::vector<RooBinning*> >)((((const ::std::vector<RooBinning*>*)o)->end)());
  else   (((const ::std::vector<RooBinning*>*)o)->end)();
}

static  void method_13000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooBinning*>*)o)->size)());
  else   (((const ::std::vector<RooBinning*>*)o)->size)();
}

static  void method_13001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooBinning*>*)o)->max_size)());
  else   (((const ::std::vector<RooBinning*>*)o)->max_size)();
}

static  void method_13002( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooBinning*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooBinning*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooBinning*)arg[1]);
  }
}

static  void method_13003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooBinning*>*)o)->capacity)());
  else   (((const ::std::vector<RooBinning*>*)o)->capacity)();
}

static  void method_13004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooBinning*>*)o)->empty)());
  else   (((const ::std::vector<RooBinning*>*)o)->empty)();
}

static  void method_13005( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooBinning*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooBinning*>*)o)->front)();
  else   (((::std::vector<RooBinning*>*)o)->front)();
}

static  void method_13012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooBinning*>*)o)->front)();
  else   (((const ::std::vector<RooBinning*>*)o)->front)();
}

static  void method_13013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooBinning*>*)o)->back)();
  else   (((::std::vector<RooBinning*>*)o)->back)();
}

static  void method_13014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooBinning*>*)o)->back)();
  else   (((const ::std::vector<RooBinning*>*)o)->back)();
}

static  void method_13015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooBinning*>*)o)->data)());
  else   (((::std::vector<RooBinning*>*)o)->data)();
}

static  void method_13016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooBinning*>*)o)->data)());
  else   (((const ::std::vector<RooBinning*>*)o)->data)();
}

static  void method_13017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooBinning*>*)o)->push_back)(*(::RooBinning* const*)arg[0]);
}

static  void method_13018( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooBinning*>*)o)->pop_back)();
}

static  void method_13019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >)((((::std::vector<RooBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0],
    *(::RooBinning* const*)arg[1]));
  else   (((::std::vector<RooBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0],
    *(::RooBinning* const*)arg[1]);
}

static  void method_13020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooBinning* const*)arg[2]);
}

static  void method_13021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >)((((::std::vector<RooBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0]));
  else   (((::std::vector<RooBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0]);
}

static  void method_13022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >)((((::std::vector<RooBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[1]));
  else   (((::std::vector<RooBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooBinning**,std::vector<RooBinning*> >*)arg[1]);
}

static  void method_13023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooBinning*>*)o)->swap)(*(::std::vector<RooBinning*>*)arg[0]);
}

static  void method_13024( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooBinning*>*)o)->clear)();
}

static void method_newdel_2751( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooBinning*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooBinning*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooBinning*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooBinning*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooBinning*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooBinning*,std::allocator<RooBinning*> >")), ::Reflex::BaseOffset< ::std::vector<RooBinning*>,::std::_Vector_base<RooBinning*,std::allocator<RooBinning*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooBinning*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooBinning*> >::Generate();
}

//------Dictionary for class vector<RooBinning*,std::allocator<RooBinning*> > -------------------------------
void __std__vector_RooBinningp__db_datamem(Reflex::Class*);
void __std__vector_RooBinningp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooBinningp__datamem_bld(&__std__vector_RooBinningp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooBinningp__funcmem_bld(&__std__vector_RooBinningp__db_funcmem);
void __std__vector_RooBinningp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooBinning*>"), typeid(::std::vector<RooBinning*>), sizeof(::std::vector<RooBinning*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2726, ::Reflex::BaseOffset< ::std::vector<RooBinning*>, ::std::_Vector_base<RooBinning*,std::allocator<RooBinning*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_12965, Reflex::Literal("std::vector<RooBinning*>::_Alloc_value_type"))
  .AddTypedef(type_2726, Reflex::Literal("std::vector<RooBinning*>::_Base"))
  .AddTypedef(type_3108, Reflex::Literal("std::vector<RooBinning*>::_Tp_alloc_type"))
  .AddTypedef(type_8057, Reflex::Literal("std::vector<RooBinning*>::_Alloc_traits"))
  .AddTypedef(type_12965, Reflex::Literal("std::vector<RooBinning*>::value_type"))
  .AddTypedef(type_12765, Reflex::Literal("std::vector<RooBinning*>::pointer"))
  .AddTypedef(type_12972, Reflex::Literal("std::vector<RooBinning*>::const_pointer"))
  .AddTypedef(type_12974, Reflex::Literal("std::vector<RooBinning*>::reference"))
  .AddTypedef(type_12976, Reflex::Literal("std::vector<RooBinning*>::const_reference"))
  .AddTypedef(type_7975, Reflex::Literal("std::vector<RooBinning*>::iterator"))
  .AddTypedef(type_7976, Reflex::Literal("std::vector<RooBinning*>::const_iterator"))
  .AddTypedef(type_3225, Reflex::Literal("std::vector<RooBinning*>::const_reverse_iterator"))
  .AddTypedef(type_3226, Reflex::Literal("std::vector<RooBinning*>::reverse_iterator"))
  .AddTypedef(type_3087, Reflex::Literal("std::vector<RooBinning*>::size_type"))
  .AddTypedef(type_2840, Reflex::Literal("std::vector<RooBinning*>::difference_type"))
  .AddTypedef(type_3108, Reflex::Literal("std::vector<RooBinning*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12985, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20703), Reflex::Literal("vector"), constructor_12986, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3087, type_12976, type_20703), Reflex::Literal("vector"), constructor_12987, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20237), Reflex::Literal("vector"), constructor_12988, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12989, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2751, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooBinningp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooBinning*,std::allocator<RooBinning*> > -------------------
void __std__vector_RooBinningp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooBinning*,std::allocator<RooBinning*> > -------------------
void __std__vector_RooBinningp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18631, type_20237), Reflex::Literal("operator="), operator_12990, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_12976), Reflex::Literal("assign"), method_12991, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7975), Reflex::Literal("begin"), method_12992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7976), Reflex::Literal("begin"), method_12993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7975), Reflex::Literal("end"), method_12994, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7976), Reflex::Literal("end"), method_12995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("size"), method_13000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("max_size"), method_13001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_12965), Reflex::Literal("resize"), method_13002, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("capacity"), method_13003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_600), Reflex::Literal("empty"), method_13004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087), Reflex::Literal("reserve"), method_13005, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12974, type_3087), Reflex::Literal("operator[]"), operator_13006, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12976, type_3087), Reflex::Literal("operator[]"), operator_13007, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12974, type_3087), Reflex::Literal("at"), method_13009, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12976, type_3087), Reflex::Literal("at"), method_13010, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12974), Reflex::Literal("front"), method_13011, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12976), Reflex::Literal("front"), method_13012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12974), Reflex::Literal("back"), method_13013, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12976), Reflex::Literal("back"), method_13014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12765), Reflex::Literal("data"), method_13015, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12972), Reflex::Literal("data"), method_13016, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_12976), Reflex::Literal("push_back"), method_13017, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("pop_back"), method_13018, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7975, type_7975, type_12976), Reflex::Literal("insert"), method_13019, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_7975, type_3087, type_12976), Reflex::Literal("insert"), method_13020, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7975, type_7975), Reflex::Literal("erase"), method_13021, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7975, type_7975, type_7975), Reflex::Literal("erase"), method_13022, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_18631), Reflex::Literal("swap"), method_13023, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("clear"), method_13024, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void constructor_13050( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >();
  else ::new(mem) ::std::vector<std::basic_string<char> >();
}

static void constructor_13051( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
}

static void constructor_13052( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  }
}

static void constructor_13053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static void destructor_13054(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::basic_string<char> >*)o)->::std::vector<std::basic_string<char> >::~vector)();
}
static  void operator_13055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_13056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_13058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_13059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_13060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_13065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->size)();
}

static  void method_13066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->max_size)();
}

static  void method_13067( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::basic_string<char>*)arg[1]);
  }
}

static  void method_13068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->capacity)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->capacity)();
}

static  void method_13069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->empty)();
}

static  void method_13070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_13077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_13078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_13079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_13080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_13081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_13082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->push_back)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13083( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->pop_back)();
}

static  void method_13084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_13086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_13087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]);
}

static  void method_13088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->swap)(*(::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_13089( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->clear)();
}

static void method_newdel_2752( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >")), ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >,::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
}

//------Dictionary for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__datamem_bld(&__std__vector_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__funcmem_bld(&__std__vector_std__basic_string_char_s__db_funcmem);
void __std__vector_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"), typeid(::std::vector<std::basic_string<char> >), sizeof(::std::vector<std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2731, ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >, ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2782, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_2731, Reflex::Literal("std::vector<std::basic_string<char> >::_Base"))
  .AddTypedef(type_3111, Reflex::Literal("std::vector<std::basic_string<char> >::_Tp_alloc_type"))
  .AddTypedef(type_8062, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_traits"))
  .AddTypedef(type_2782, Reflex::Literal("std::vector<std::basic_string<char> >::value_type"))
  .AddTypedef(type_12859, Reflex::Literal("std::vector<std::basic_string<char> >::pointer"))
  .AddTypedef(type_13037, Reflex::Literal("std::vector<std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_13039, Reflex::Literal("std::vector<std::basic_string<char> >::reference"))
  .AddTypedef(type_13041, Reflex::Literal("std::vector<std::basic_string<char> >::const_reference"))
  .AddTypedef(type_7985, Reflex::Literal("std::vector<std::basic_string<char> >::iterator"))
  .AddTypedef(type_7986, Reflex::Literal("std::vector<std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_3243, Reflex::Literal("std::vector<std::basic_string<char> >::const_reverse_iterator"))
  .AddTypedef(type_3244, Reflex::Literal("std::vector<std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_3087, Reflex::Literal("std::vector<std::basic_string<char> >::size_type"))
  .AddTypedef(type_2840, Reflex::Literal("std::vector<std::basic_string<char> >::difference_type"))
  .AddTypedef(type_3111, Reflex::Literal("std::vector<std::basic_string<char> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13050, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20767), Reflex::Literal("vector"), constructor_13051, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3087, type_13041, type_20767), Reflex::Literal("vector"), constructor_13052, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18842), Reflex::Literal("vector"), constructor_13053, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13054, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2752, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20238, type_18842), Reflex::Literal("operator="), operator_13055, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_13041), Reflex::Literal("assign"), method_13056, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7985), Reflex::Literal("begin"), method_13057, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7986), Reflex::Literal("begin"), method_13058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7985), Reflex::Literal("end"), method_13059, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7986), Reflex::Literal("end"), method_13060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("size"), method_13065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("max_size"), method_13066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_2782), Reflex::Literal("resize"), method_13067, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("capacity"), method_13068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_600), Reflex::Literal("empty"), method_13069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087), Reflex::Literal("reserve"), method_13070, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13039, type_3087), Reflex::Literal("operator[]"), operator_13071, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13041, type_3087), Reflex::Literal("operator[]"), operator_13072, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13039, type_3087), Reflex::Literal("at"), method_13074, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13041, type_3087), Reflex::Literal("at"), method_13075, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13039), Reflex::Literal("front"), method_13076, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13041), Reflex::Literal("front"), method_13077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13039), Reflex::Literal("back"), method_13078, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13041), Reflex::Literal("back"), method_13079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12859), Reflex::Literal("data"), method_13080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13037), Reflex::Literal("data"), method_13081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_13041), Reflex::Literal("push_back"), method_13082, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("pop_back"), method_13083, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7985, type_7985, type_13041), Reflex::Literal("insert"), method_13084, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_7985, type_3087, type_13041), Reflex::Literal("insert"), method_13085, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7985, type_7985), Reflex::Literal("erase"), method_13086, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7985, type_7985, type_7985), Reflex::Literal("erase"), method_13087, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20238), Reflex::Literal("swap"), method_13088, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("clear"), method_13089, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PIDResult,std::allocator<PIDResult> > -------------------------------
static void constructor_13115( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PIDResult>();
  else ::new(mem) ::std::vector<PIDResult>();
}

static void constructor_13116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PIDResult>(*(const ::std::allocator<PIDResult>*)arg[0]);
  else ::new(mem) ::std::vector<PIDResult>(*(const ::std::allocator<PIDResult>*)arg[0]);
}

static void constructor_13117( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PIDResult>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PIDResult>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PIDResult>(*(::std::size_t*)arg[0],
      *(const ::PIDResult*)arg[1]);
  else ::new(mem) ::std::vector<PIDResult>(*(::std::size_t*)arg[0],
      *(const ::PIDResult*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PIDResult>(*(::std::size_t*)arg[0],
      *(const ::PIDResult*)arg[1],
      *(const ::std::allocator<PIDResult>*)arg[2]);
  else ::new(mem) ::std::vector<PIDResult>(*(::std::size_t*)arg[0],
      *(const ::PIDResult*)arg[1],
      *(const ::std::allocator<PIDResult>*)arg[2]);
  }
}

static void constructor_13118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PIDResult>(*(const ::std::vector<PIDResult>*)arg[0]);
  else ::new(mem) ::std::vector<PIDResult>(*(const ::std::vector<PIDResult>*)arg[0]);
}

static void destructor_13119(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PIDResult>*)o)->::std::vector<PIDResult>::~vector)();
}
static  void operator_13120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PIDResult>*)o)->operator=)(*(const ::std::vector<PIDResult>*)arg[0]);
  else   (((::std::vector<PIDResult>*)o)->operator=)(*(const ::std::vector<PIDResult>*)arg[0]);
}

static  void method_13121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PIDResult>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PIDResult*)arg[1]);
}

static  void method_13122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >)((((::std::vector<PIDResult>*)o)->begin)());
  else   (((::std::vector<PIDResult>*)o)->begin)();
}

static  void method_13123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PIDResult*,std::vector<PIDResult> >)((((const ::std::vector<PIDResult>*)o)->begin)());
  else   (((const ::std::vector<PIDResult>*)o)->begin)();
}

static  void method_13124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >)((((::std::vector<PIDResult>*)o)->end)());
  else   (((::std::vector<PIDResult>*)o)->end)();
}

static  void method_13125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PIDResult*,std::vector<PIDResult> >)((((const ::std::vector<PIDResult>*)o)->end)());
  else   (((const ::std::vector<PIDResult>*)o)->end)();
}

static  void method_13130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PIDResult>*)o)->size)());
  else   (((const ::std::vector<PIDResult>*)o)->size)();
}

static  void method_13131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PIDResult>*)o)->max_size)());
  else   (((const ::std::vector<PIDResult>*)o)->max_size)();
}

static  void method_13132( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PIDResult>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PIDResult>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PIDResult*)arg[1]);
  }
}

static  void method_13133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PIDResult>*)o)->capacity)());
  else   (((const ::std::vector<PIDResult>*)o)->capacity)();
}

static  void method_13134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PIDResult>*)o)->empty)());
  else   (((const ::std::vector<PIDResult>*)o)->empty)();
}

static  void method_13135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PIDResult>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PIDResult>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PIDResult>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PIDResult>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PIDResult>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PIDResult>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PIDResult>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PIDResult>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PIDResult>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PIDResult>*)o)->front)();
  else   (((::std::vector<PIDResult>*)o)->front)();
}

static  void method_13142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PIDResult>*)o)->front)();
  else   (((const ::std::vector<PIDResult>*)o)->front)();
}

static  void method_13143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PIDResult>*)o)->back)();
  else   (((::std::vector<PIDResult>*)o)->back)();
}

static  void method_13144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PIDResult>*)o)->back)();
  else   (((const ::std::vector<PIDResult>*)o)->back)();
}

static  void method_13145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PIDResult>*)o)->data)());
  else   (((::std::vector<PIDResult>*)o)->data)();
}

static  void method_13146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PIDResult>*)o)->data)());
  else   (((const ::std::vector<PIDResult>*)o)->data)();
}

static  void method_13147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PIDResult>*)o)->push_back)(*(const ::PIDResult*)arg[0]);
}

static  void method_13148( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PIDResult>*)o)->pop_back)();
}

static  void method_13149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >)((((::std::vector<PIDResult>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0],
    *(const ::PIDResult*)arg[1]));
  else   (((::std::vector<PIDResult>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0],
    *(const ::PIDResult*)arg[1]);
}

static  void method_13150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PIDResult>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PIDResult*)arg[2]);
}

static  void method_13151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >)((((::std::vector<PIDResult>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0]));
  else   (((::std::vector<PIDResult>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0]);
}

static  void method_13152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >)((((::std::vector<PIDResult>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[1]));
  else   (((::std::vector<PIDResult>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PIDResult*,std::vector<PIDResult> >*)arg[1]);
}

static  void method_13153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PIDResult>*)o)->swap)(*(::std::vector<PIDResult>*)arg[0]);
}

static  void method_13154( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PIDResult>*)o)->clear)();
}

static void method_newdel_2753( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PIDResult> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PIDResult> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PIDResult> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PIDResult> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PIDResult> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x49( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PIDResult,std::allocator<PIDResult> >")), ::Reflex::BaseOffset< ::std::vector<PIDResult>,::std::_Vector_base<PIDResult,std::allocator<PIDResult> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PIDResult> >::Generate();
  else ::Reflex::Proxy< ::std::vector<PIDResult> >::Generate();
}

//------Dictionary for class vector<PIDResult,std::allocator<PIDResult> > -------------------------------
void __std__vector_PIDResult__db_datamem(Reflex::Class*);
void __std__vector_PIDResult__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PIDResult__datamem_bld(&__std__vector_PIDResult__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PIDResult__funcmem_bld(&__std__vector_PIDResult__db_funcmem);
void __std__vector_PIDResult__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PIDResult>"), typeid(::std::vector<PIDResult>), sizeof(::std::vector<PIDResult>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2725, ::Reflex::BaseOffset< ::std::vector<PIDResult>, ::std::_Vector_base<PIDResult,std::allocator<PIDResult> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1152, Reflex::Literal("std::vector<PIDResult>::_Alloc_value_type"))
  .AddTypedef(type_2725, Reflex::Literal("std::vector<PIDResult>::_Base"))
  .AddTypedef(type_3112, Reflex::Literal("std::vector<PIDResult>::_Tp_alloc_type"))
  .AddTypedef(type_8056, Reflex::Literal("std::vector<PIDResult>::_Alloc_traits"))
  .AddTypedef(type_1152, Reflex::Literal("std::vector<PIDResult>::value_type"))
  .AddTypedef(type_12746, Reflex::Literal("std::vector<PIDResult>::pointer"))
  .AddTypedef(type_13102, Reflex::Literal("std::vector<PIDResult>::const_pointer"))
  .AddTypedef(type_13104, Reflex::Literal("std::vector<PIDResult>::reference"))
  .AddTypedef(type_13106, Reflex::Literal("std::vector<PIDResult>::const_reference"))
  .AddTypedef(type_7973, Reflex::Literal("std::vector<PIDResult>::iterator"))
  .AddTypedef(type_7974, Reflex::Literal("std::vector<PIDResult>::const_iterator"))
  .AddTypedef(type_3223, Reflex::Literal("std::vector<PIDResult>::const_reverse_iterator"))
  .AddTypedef(type_3224, Reflex::Literal("std::vector<PIDResult>::reverse_iterator"))
  .AddTypedef(type_3087, Reflex::Literal("std::vector<PIDResult>::size_type"))
  .AddTypedef(type_2840, Reflex::Literal("std::vector<PIDResult>::difference_type"))
  .AddTypedef(type_3112, Reflex::Literal("std::vector<PIDResult>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13115, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20690), Reflex::Literal("vector"), constructor_13116, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3087, type_13106, type_20690), Reflex::Literal("vector"), constructor_13117, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20514), Reflex::Literal("vector"), constructor_13118, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13119, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2753, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PIDResult__funcmem_bld);
}

//------Delayed data member builder for class vector<PIDResult,std::allocator<PIDResult> > -------------------
void __std__vector_PIDResult__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PIDResult,std::allocator<PIDResult> > -------------------
void __std__vector_PIDResult__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20823, type_20514), Reflex::Literal("operator="), operator_13120, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_13106), Reflex::Literal("assign"), method_13121, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7973), Reflex::Literal("begin"), method_13122, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7974), Reflex::Literal("begin"), method_13123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7973), Reflex::Literal("end"), method_13124, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7974), Reflex::Literal("end"), method_13125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("size"), method_13130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("max_size"), method_13131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087, type_1152), Reflex::Literal("resize"), method_13132, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3087), Reflex::Literal("capacity"), method_13133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_600), Reflex::Literal("empty"), method_13134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_3087), Reflex::Literal("reserve"), method_13135, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13104, type_3087), Reflex::Literal("operator[]"), operator_13136, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13106, type_3087), Reflex::Literal("operator[]"), operator_13137, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13104, type_3087), Reflex::Literal("at"), method_13139, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13106, type_3087), Reflex::Literal("at"), method_13140, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13104), Reflex::Literal("front"), method_13141, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13106), Reflex::Literal("front"), method_13142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13104), Reflex::Literal("back"), method_13143, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13106), Reflex::Literal("back"), method_13144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12746), Reflex::Literal("data"), method_13145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13102), Reflex::Literal("data"), method_13146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_13106), Reflex::Literal("push_back"), method_13147, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("pop_back"), method_13148, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7973, type_7973, type_13106), Reflex::Literal("insert"), method_13149, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_7973, type_3087, type_13106), Reflex::Literal("insert"), method_13150, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7973, type_7973), Reflex::Literal("erase"), method_13151, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7973, type_7973, type_7973), Reflex::Literal("erase"), method_13152, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100, type_20823), Reflex::Literal("swap"), method_13153, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1100), Reflex::Literal("clear"), method_13154, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RICHTrackDataSet_dict(); 
      __PIDCrossTable_dict(); 
      __MUONTrackDataSet_dict(); 
      __PIDTrackDataSet_dict(); 
      __MultiTrackCalibTool_dict(); 
      __PIDResult_dict(); 
      __WeightDataSetTool_PIDTrackDataSet__dict(); 
      __WeightDataSetTool_MUONTrackDataSet__dict(); 
      __WeightDataSetTool_RICHTrackDataSet__dict(); 
      __EvtTrackDataSet_dict(); 
      __WeightDataSetTool_EvtTrackDataSet__dict(); 
      __TrackDataSet_dict(); 
      __WeightDataSetTool_TrackDataSet__dict(); 
      __LHCbPIDTrackDataSet_dict(); 
      __PIDTable_dict(); 
      __std__pair_std__basic_string_char__std__basic_string_char_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__dict(); 
      __GenericDataSet_dict(); 
      __PerfCalculator_GenericDataSet__dict(); 
      __PerfCalculator_LHCbPIDTrackDataSet__dict(); 
      __PerfCalculator_PIDTrackDataSet__dict(); 
      __PerfCalculator_MUONTrackDataSet__dict(); 
      __PerfCalculator_RICHTrackDataSet__dict(); 
      __PerfCalculator_EvtTrackDataSet__dict(); 
      __PerfCalculator_TrackDataSet__dict(); 
      __TrkPIDParams_dict(); 
      __DataBinCuts_dict(); 
      __std__pair_std__basic_string_char__RooBinningp__dict(); 
      __std__list_std__pair_std__basic_string_char__RooBinningp_s__dict(); 
      __std__vector_RooBinningp__dict(); 
      __std__vector_std__basic_string_char_s__dict(); 
      __std__vector_PIDResult__dict(); 
    }
    ~Dictionaries() {
      type_471.Unload(); // class RICHTrackDataSet 
      type_511.Unload(); // class PIDCrossTable 
      type_700.Unload(); // class MUONTrackDataSet 
      type_952.Unload(); // class PIDTrackDataSet 
      type_974.Unload(); // class MultiTrackCalibTool 
      type_1152.Unload(); // class PIDResult 
      type_1396.Unload(); // class WeightDataSetTool<PIDTrackDataSet> 
      type_1397.Unload(); // class WeightDataSetTool<MUONTrackDataSet> 
      type_1398.Unload(); // class WeightDataSetTool<RICHTrackDataSet> 
      type_1564.Unload(); // class EvtTrackDataSet 
      type_1399.Unload(); // class WeightDataSetTool<EvtTrackDataSet> 
      type_1877.Unload(); // class TrackDataSet 
      type_1400.Unload(); // class WeightDataSetTool<TrackDataSet> 
      type_1763.Unload(); // class LHCbPIDTrackDataSet 
      type_1802.Unload(); // class PIDTable 
      type_2990.Unload(); // class std::pair<std::basic_string<char>,std::basic_string<char> > 
      type_1912.Unload(); // class std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > 
      type_2102.Unload(); // class GenericDataSet 
      type_2375.Unload(); // class PerfCalculator<GenericDataSet> 
      type_2376.Unload(); // class PerfCalculator<LHCbPIDTrackDataSet> 
      type_2377.Unload(); // class PerfCalculator<PIDTrackDataSet> 
      type_2378.Unload(); // class PerfCalculator<MUONTrackDataSet> 
      type_2379.Unload(); // class PerfCalculator<RICHTrackDataSet> 
      type_2380.Unload(); // class PerfCalculator<EvtTrackDataSet> 
      type_2381.Unload(); // class PerfCalculator<TrackDataSet> 
      type_2455.Unload(); // class TrkPIDParams 
      type_2503.Unload(); // class DataBinCuts 
      type_2991.Unload(); // class std::pair<std::basic_string<char>,RooBinning*> 
      type_2711.Unload(); // class std::list<std::pair<std::basic_string<char>,RooBinning*> > 
      type_2751.Unload(); // class std::vector<RooBinning*> 
      type_2752.Unload(); // class std::vector<std::basic_string<char> > 
      type_2753.Unload(); // class std::vector<PIDResult> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
